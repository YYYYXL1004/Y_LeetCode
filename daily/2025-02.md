# 2025年2月 学习记录

## 2.5

**今日学习：**
- [x] 链表反转的递归三要素
- [x] 反转整个链表（迭代/递归）
- [x] 反转链表前N个节点
- [x] 反转链表的指定区间 [left, right]
- [x] K个一组翻转链表

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 206 | 反转链表 | 简单 | ✅ |
| 92 | 反转链表 II | 中等 | ✅ |
| 25 | K 个一组翻转链表 | 困难 | ✅ |

**笔记：**
- **递归三要素**：
  1. **递归函数的定义是什么？** reverseN(head, n): 反转以head为头的前n个节点，返回新头节点
  2. **递归终止条件是什么？** `if (n == 1)` 只有1个节点时，不需要反转
  3. **这一层递归应该做什么？** 假设 `reverseN(head->next, n-1)` 已经正确反转了后面n-1个节点，我只需要把当前head连接到正确位置

- **反转整个链表**：
  - **迭代版**：
    ```cpp
    ListNode *pre = nullptr, *cur = head, *nxt = head->next;
    while(cur != nullptr) {
        cur->next = pre;
        pre = cur;
        cur = nxt;
        if(nxt != nullptr) nxt = nxt->next;
    }
    return pre;
    ```
  - **递归版**：
    ```cpp
    if(head == nullptr || head->next == nullptr) return head;
    ListNode* last = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return last;
    ```

- **反转前N个节点（模板）**：
  - **迭代版**（推荐）：
    ```cpp
    ListNode* reverseN(ListNode* head, int n) {
        if(!head || !head->next) return head;
        ListNode *pre = nullptr, *cur = head, *nxt = head->next;
        while(n--) {
            cur->next = pre;
            pre = cur;
            cur = nxt;
            if(nxt != nullptr) nxt = nxt->next;
        }
        head->next = cur;  // 关键：原head连接到第n+1个节点
        return pre;
    }
    ```
  - **递归版**：
    ```cpp
    ListNode* successor = nullptr;
    ListNode* reverseN(ListNode* head, int n) {
        if(n == 1) {
            successor = head->next;  // 记录第n+1个节点
            return head;
        }
        ListNode* last = reverseN(head->next, n - 1); // 假设子问题已解决
        head->next->next = head;
        head->next = successor;
        return last;
    }
    ```

- **反转链表 II（区间反转）**：
  - **递归思路**：当 `left == 1` 时，相当于反转前 `right` 个节点
  - 否则递归：`head->next = reverseBetween(head->next, left - 1, right - 1)`
  - **迭代思路**：找到区间前一个节点，反转区间内节点，重新连接

- **K个一组翻转链表**：
  ```cpp
  ListNode* reverseKGroup(ListNode* head, int k) {
      if(k == 1 || !head || !head->next) return head;
      ListNode *a = head, *b = head;
      for(int i = 0; i < k; i++) {
          if(b == nullptr) return head;  // 不足k个直接返回
          b = b->next;
      }
      ListNode* newHead = reverseN(a, k);  // 反转前k个
      a->next = reverseKGroup(b, k);       // 递归处理后面的
      return newHead;
  }
  ```
  - **关键点**：
    - 区间 `[a, b)` 包含k个待反转节点
    - 反转后 `a` 变成该组的尾节点，需要连接下一组
    - 不足k个节点时直接返回原head

- **链表反转的常见错误**：
  - ❌ 忘记处理 `nxt` 为空的情况
  - ❌ 迭代中 `if(nxt != nullptr)` 写成 `while`
  - ❌ 反转前N个节点后忘记连接后续节点 `head->next = cur`
  - ✅ 想不清楚就画图，用 `1->2->3->4` 反转前3个试试

- **迭代 vs 递归选择**：
  - **迭代**：空间 O(1)，逻辑直观，适合面试手写
  - **递归**：代码简洁，但有栈空间开销 O(n)
  - **建议**：掌握迭代版作为主力，递归版理解思路

---

## 2.4

**今日学习：**
- [x] Fisher-Yates 洗牌算法（从后往前/从前往后）
- [x] 蓄水池抽样算法（Reservoir Sampling）
- [x] 前缀和 + 二分查找实现按权重随机选择
- [x] 二分查找的两种实现：STL `lower_bound` vs 手写
- [x] 随机算法的概率证明
- [x] C++ 随机数生成器：`rand()` vs `<random>` 库
- [x] 双指针技巧：对撞指针在有序数组中的应用
- [x] 矩阵操作：转置、对角线处理、坐标映射
- [x] 一维数组模拟：将二维问题降维处理
- [x] 字符串遍历：按列优先 vs 按行优先

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 382 | 链表随机节点 | 中等 | ✅ |
| 384 | 打乱数组 | 中等 | ✅ |
| 528 | 按权重随机选择 | 中等 | ✅ |
| 398 | 随机数索引 | 中等 | ✅ |
| 977 | 有序数组的平方 | 简单 | ✅ |
| 867 | 转置矩阵 | 简单 | ✅ |
| 1329 | 将矩阵按对角线排序 | 中等 | ✅ |
| 1260 | 二维网格迁移 | 中等 | ✅ |
| 14 | 最长公共前缀 | 简单 | ✅ |

**笔记：**
- **Fisher-Yates 洗牌算法**：
  - **从后往前**（推荐）：
    ```cpp
    for (int i = n-1; i > 0; i--) {
        int j = rand() % (i + 1);  // [0, i]
        swap(arr[i], arr[j]);
    }
    ```
  - **从前往后**：
    ```cpp
    for (int i = 0; i < n; i++) {
        int j = i + rand() % (n - i);  // [i, n-1]
        swap(arr[i], arr[j]);
    }
    ```
  - 核心思想：逐步缩小未处理区域，保证每种排列概率相等（1/n!）
  - 时间复杂度 O(n)，空间复杂度 O(1)
  - ⚠️ 注意：随机范围是 `i + 1` 而不是固定的 `n - 1`

- **蓄水池抽样算法**：
  - 用于在**不知道数据总量**或**无法随机访问**的情况下等概率随机选择
  - 核心思想：遍历时第 i 个元素以 `1/i` 概率被选中
  - ```cpp
    int count = 0, result;
    while (curr) {
        count++;
        if (rand() % count == 0) result = curr->val;
        curr = curr->next;
    }
    ```
  - **概率证明**：
    - 第 k 个元素被选中概率 = (1/k) × (k/(k+1)) × ... × ((n-1)/n) = 1/n
    - 即：以 1/k 概率选中，后续不被替换的概率为 k/n
  - 适用场景：链表随机节点、流式数据随机采样
  - 时间 O(n)，空间 O(1)

- **按权重随机选择（前缀和+二分）**：
  - 步骤：
    1. 构建前缀和数组：`w = [1, 3, 2]` → `preSum = [1, 4, 6]`
    2. 生成 `[1, total]` 的随机数
    3. 二分查找第一个 `>= target` 的位置
  - 区间映射：权重越大，对应区间越长，被命中概率越高
    - 索引0: [1, 1] 长度1
    - 索引1: [2, 4] 长度3
    - 索引2: [5, 6] 长度2
  - 时间：构造 O(n)，pickIndex O(log n)

- **二分查找实现对比**：
  - **使用 `lower_bound`**（推荐熟练时使用）：
    - 优点：代码简洁，STL 可靠
    - 缺点：需要记住语义（`>=` 还是 `>`）
    ```cpp
    return lower_bound(preSum.begin(), preSum.end(), target) - preSum.begin();
    ```
  - **手写二分**（推荐不熟练时使用）：
    - 优点：逻辑清晰，完全可控
    - 缺点：容易写错边界
    ```cpp
    int left = 0, right = n - 1;
    while (left <= right) { 
        int mid = left + (right - left) / 2;
        if (preSum[mid] < target) left = mid + 1;
        else right = mid - 1; 
    }
    return left;
    ```
  - **比赛建议**：用自己最有把握的方式，保证不出错比代码简洁更重要

- **C++ 随机数生成器对比**：
  - **`rand()` 的问题**：
    - 伪随机数质量不佳，某些编译器实现可能产生固定序列
    - 依赖全局状态，线程不安全
    - 随机范围有限（通常为 `RAND_MAX = 32767`）
    - LeetCode 环境下可能导致部分测试用例失败
  - **`<random>` 库**（推荐）：
    ```cpp
    class Solution {
    private:
        mt19937 gen;  // Mersenne Twister 生成器
    public:
        Solution() : gen(random_device{}()) {}  // 真随机种子初始化
        
        int getRandom(int n) {
            uniform_int_distribution<int> dis(0, n - 1);
            return dis(gen);
        }
    };
    ```
  - **关键组件**：
    - `random_device{}`：真随机数种子（基于硬件）
    - `mt19937`：高质量伪随机数生成器（周期 2^19937-1）
    - `uniform_int_distribution`：均匀分布，确保每个数概率相等
  - **优势**：
    - 随机质量高，符合统计学分布
    - 线程安全（每个对象独立状态）
    - 可重现（可用固定种子调试）
  - **使用建议**：
    - ✅ 竞赛/面试：优先使用 `<random>`
    - ⚠️ 简单题目：`rand()` 可能够用，但注意测试环境
    - 🔧 调试技巧：`mt19937 gen(42);` 使用固定种子

- **有序数组的平方**：
  - **双指针对撞**：由于原数组有序，负数平方后递减，正数平方后递增
  - 从两端向中间比较绝对值，较大值从后往前填入结果数组
  - ```cpp
    int i = 0, j = n - 1, p = n - 1;
    while(i <= j) {
        if(abs(nums[i]) >= abs(nums[j])) {
            res[p--] = nums[i] * nums[i];
            i++;
        } else {
            res[p--] = nums[j] * nums[j];
            j--;
        }
    }
    ```
  - 时间 O(n)，优于排序的 O(n log n)
  - 核心：利用原数组的有序性，避免排序

- **转置矩阵**：
  - **方法一**：直接转置 `res[j][i] = matrix[i][j]`
    - 按行遍历原矩阵，按列填入新矩阵
  - **方法二**：按列优先遍历（思维转换）
    ```cpp
    for(int j = 0; j < n; j++)      // 遍历每一列
        for(int i = 0; i < m; i++)  // 遍历该列的每一行
            res[j][i] = matrix[i][j]; // 第j列变成第j行
    ```
  - 注意：转置后维度变化 `m×n → n×m`
  - 时间 O(m×n)，空间 O(n×m)

- **将矩阵按对角线排序**：
  - **关键观察**：同一对角线上的元素满足 `i - j = 常数`
  - **方法一**：哈希表 + `list`
    - `list` 的 `sort()` 函数：O(n log n)
    - `pop_front()` / `pop_back()`：O(1)
    - 适合频繁删除操作
  - **方法二**：哈希表 + `vector` + 索引（推荐）
    ```cpp
    unordered_map<int, vector<int>> mp;
    unordered_map<int, int> idx; // 记录每条对角线的当前索引
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            mp[i - j].push_back(mat[i][j]);
        }
    }
    for(auto& [key, vec] : mp) {
        sort(vec.begin(), vec.end());
        idx[key] = 0;
    }
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            res[i][j] = mp[i - j][idx[i - j]++];
        }
    }
    ```
  - **对角线分类**：
    - 主对角线及以上：`i - j <= 0`
    - 主对角线以下：`i - j > 0`
  - 时间 O(m×n×log(min(m,n)))，每条对角线最多 min(m,n) 个元素

- **二维网格迁移**：
  - **方法一**：暴力模拟 k 次移动
    - 每次移动：最后一个元素移到第一个位置，其余元素右移
    - 时间 O(k×m×n)，空间 O(m×n)
  - **方法二**：一维数组映射（推荐）
    - **核心思想**：将二维数组展平为一维，右移 k 位后再映射回二维
    - ```cpp
    int oldPos = i * n + j;           // 原位置
    int newPos = (oldPos + k) % total; // 新位置（取模处理循环）
    res[newPos / n][newPos % n] = grid[i][j];
    ```
  - **优化**：`k %= total` 避免重复计算
  - 时间 O(m×n)，空间 O(m×n)
  - **坐标映射公式**：
    - 一维 → 二维：`(idx / n, idx % n)`
    - 二维 → 一维：`i * n + j`

- **最长公共前缀**：
  - **按列遍历**：逐列比较所有字符串的对应字符
  - ```cpp
    int minLen = INT_MAX;
    for(auto& str : strs) minLen = min(minLen, (int)str.size());
    
    for(int j = 0; j < minLen; j++) {
        char c = strs[0][j];
        for(int i = 1; i < strs.size(); i++) {
            if(strs[i][j] != c) {
                return strs[0].substr(0, j);
            }
        }
    }
    return strs[0].substr(0, minLen);
    ```
  - **注意事项**：
    - `str.size()` 返回 `size_t`（无符号类型），与 `int` 比较需强制转换
    - `substr(pos, len)`：从 pos 开始截取 len 个字符
    - 边界条件：空数组、单字符串、无公共前缀
  - 时间 O(S)，S 为所有字符串的字符总数
  - 优化：先找最短字符串，避免越界

- **矩阵问题的通用技巧**：
  - **降维处理**：二维 ⟺ 一维（适用于规律性操作）
  - **坐标映射**：`(i, j) ⟺ i * n + j`
  - **对角线识别**：`i - j`（主对角线）、`i + j`（副对角线）
  - **遍历顺序**：按行、按列、按对角线根据问题选择
  - **空间优化**：能否原地修改或使用 O(1) 额外空间

- **类型转换注意事项**：
  - `size_t` 是无符号类型，与有符号类型比较时需要转换
  - `static_cast<int>(str.size())` 或 `(int)str.size()`
  - 避免无符号整数下溢：`size_t a = 0; a - 1` 会变成很大的数

- **常见错误**：
  - ❌ `rand() % (n - 1)` → 最后一个位置无法被选中
  - ❌ `preSum[target]` → target 是数值不是索引，会越界
  - ❌ `while (left <= right)` 配合 `right = mid` → 死循环
  - ❌ 每次调用都创建新的 `uniform_int_distribution` 对象 → 性能低但正确
  - ✅ `rand() % (i + 1)` → 范围 [0, i]
  - ✅ `preSum[mid] < target` → 比较数值
  - ✅ `while (left < right)` 配合 `right = mid` → 查找第一个位置
  - ✅ 将 `mt19937` 作为类成员变量，保持状态连续性

---

## 2.3

**今日学习：**
- [x] 二分查找算法框架
- [x] 二分查找的变体：寻找左侧边界
- [x] 转化问题：最值问题 → 二分搜索
- [x] 单调性判断：f(x) 关于 x 的单调性
- [x] 矩阵重塑：坐标映射技巧

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 704 | 二分查找 | 简单 | ✅ |
| 875 | 爱吃香蕉的珂珂 | 中等 | ✅ |
| 1011 | 在 D 天内送达包裹的能力 | 中等 | ✅ |
| LCR 172 | 统计目标成绩的出现次数 | 简单 | ✅ |
| 410 | 分割数组的最大值 | 困难 | ✅ |
| 566 | 重塑矩阵 | 简单 | ✅ |

**笔记：**
- **二分查找基础框架**：
  ```cpp
  int left = 0, right = nums.size() - 1;
  while(left <= right) { // 左闭右闭区间 [left, right]
      int mid = left + (right - left) / 2;
      if(nums[mid] == target) return mid;
      else if(nums[mid] < target) left = mid + 1;
      else if(nums[mid] > target) right = mid - 1;
  }
  return -1;
  ```
- **寻找左侧边界**（找满足条件的最小值）：
  - 当 `f(mid) <= target` 时，`right = mid - 1`（收缩右边界）
  - 当 `f(mid) > target` 时，`left = mid + 1`
  - 最终返回 `left`
- 当目标元素 target 不存在数组 nums 中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读：(都是等价的)
  - 1、返回的这个值是 nums 中大于等于 target 的最小元素索引。
  - 2、返回的这个值是 target 应该插入在 nums 中的索引位置。
  - 3、返回的这个值是 nums 中小于 target 的元素个数。
- **爱吃香蕉的珂珂**：
  - 定义 `f(x)` 为以速度 x 吃完所有香蕉需要的小时数
  - `f(x)` 随 x 增加而**单调递减**
  - 目标：找最小的 x 使得 `f(x) <= h`
  - 搜索空间：`[1, max(piles)]` 或 `[1, 1e9]`
  - 注意：`piles[i] / x` 向上取整 = `(piles[i] + x - 1) / x` 或判断余数
- **在 D 天内送达包裹的能力**：
  - 定义 `f(x)` 为运载能力为 x 时需要的天数
  - `f(x)` 随 x 增加而**单调递减**
  - 目标：找最小的 x 使得 `f(x) <= days`
  - 搜索空间：`[max(weights), sum(weights)]`
  - 关键：`left` 初始化为最大重量（船至少能装下最重的包裹）
- **分割数组的最大值**：
  - **问题转化**：与"在 D 天内送达包裹"完全一样的思路
  - 定义 `f(x)` 为当子数组和的最大值为 x 时，需要的子数组个数
  - `f(x)` 随 x 增加而**单调递减**
  - 目标：找最小的 x 使得 `f(x) <= k`
  - 搜索空间：`[max(nums), sum(nums)]`
  - 核心：将"最小化最大值"转化为二分搜索
- **重塑矩阵**：
  - **方法一**：通过一维数组中转，空间复杂度 O(m*n)
  - **方法二**：数学映射，O(1) 额外空间（推荐）
    - 一维索引 `i` → 原矩阵：`mat[i/n][i%n]`
    - 一维索引 `i` → 新矩阵：`res[i/c][i%c]`
  - 关键：判断 `r * c != m * n` 时返回原矩阵
- **二分查找的本质**：
  - 在单调函数上寻找边界
  - 将"求最值"问题转化为"判定"问题
  - 关键是找到单调性并正确定义 `f(x)`

---

## 2.2

**今日学习：**
- [x] 滑动窗口算法框架
- [x] 滑动窗口的四大应用场景
- [x] 哈希表记录窗口内字符频率
- [x] 子数组问题的转化思维

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 3 | 无重复字符的最长子串 | 中等 | ✅ |
| 76 | 最小覆盖子串 | 困难 | ✅ |
| 438 | 找到字符串中所有字母异位词 | 中等 | ✅ |
| 567 | 字符串的排列 | 中等 | ✅ |
| 1658 | 将 x 减到 0 的最小操作数 | 中等 | ✅ |

**笔记：**
- **滑动窗口框架**：
  ```cpp
  int left = 0, right = 0;
  while (right < s.size()) {
      // 扩大窗口
      window.add(s[right]);
      right++;
      
      while (window needs shrink) {
          // 缩小窗口
          window.remove(s[left]);
          left++;
      }
  }
  ```
- **最小覆盖子串**：
  - 用 `need` 记录目标字符频率，`window` 记录窗口内字符频率
  - `valid` 记录窗口中满足 `need` 条件的字符种类数
  - 当 `valid == need.size()` 时更新最小长度
  - 窗口收缩条件：满足覆盖要求时
- **字符串的排列**：
  - 与最小覆盖子串类似，但要求窗口大小固定为 `s1.length()`
  - 当 `right - left >= n` 时判断是否满足条件并收缩窗口
  - **关键**：必须在窗口大小恰好为 n 且字符频率匹配时返回 true
  - **找所有字母异位词**：
  - 在固定窗口大小 `p.size()` 内找所有满足条件的起始位置
  - 每次窗口满足条件时记录 `left` 索引
- **无重复字符的最长子串**：
  - 窗口收缩条件：`window[c] > 1`（出现重复字符）
  - 收缩后保证窗口内无重复，然后更新最大长度
- **将 x 减到 0 的最小操作数**：
  - **转化思维**：从两端删除和为 x ⟺ 保留中间和为 `sum - x` 的最长子数组
  - 用滑动窗口找和为 `target = sum - x` 的最长子数组
  - 答案为 `n - maxLen`（若不存在返回 -1）
- **滑动窗口 vs 双指针**：
  - 滑动窗口适合"连续子数组/子串"问题
  - 双指针更通用，可处理排序数组、链表等

---

## 2.1

**今日学习：**
- [x] 双指针技巧：对撞指针
- [x] 贪心算法：移动较小边界
- [x] 优先队列（小顶堆）+ BFS：接雨水II
- [x] 计数排序：适用于值域较小的场景
- [x] 三指针技巧：荷兰国旗问题

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 11 | 盛最多水的容器 | 中等 | ✅ |
| 42 | 接雨水 | 困难 | ✅ |
| 75 | 颜色分类 | 中等 | ✅ |
| 88 | 合并两个有序数组 | 简单 | ✅ |
| 407 | 接雨水 II | 困难 | ✅ |

**笔记：**
- 盛最多水的容器：双指针对撞，每次移动高度较小的指针（贪心思想），因为移动较高的指针不可能得到更大面积
- 接雨水三种方法：
  - 暴力：每个位置找左右最高值，O(n²)
  - 备忘录：预处理左右最高值数组，O(n) 时间 O(n) 空间（推荐）
  - 双指针：动态维护 l_max 和 r_max，O(n) 时间 O(1) 空间
- 接雨水II（三维版本）：
  - 核心思想：水桶原理 + 从外向内 BFS
  - 用优先队列维护当前最低边界点（小顶堆）
  - 积水量 = max(0, 围栏高度 - 当前高度)
  - 新边界高度 = max(围栏高度, 实际地面高度)
- 颜色分类（荷兰国旗问题）：
  - 方法一：计数排序，统计每个颜色出现次数后重新填充，O(n) 时间 O(1) 空间
  - 方法二：三指针，p0 指向 0 区间末尾，p2 指向 2 区间开头，p 遍历，交换 0 后 p++，交换 2 后 p 不动（因为交换来的元素未处理）
- 合并两个有序数组：从后往前双指针，避免覆盖 nums1 的有效元素

---

<!-- 模板
## 2.XX

**今日学习：**
- [ ] 

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| | | | |

**笔记：**
- 
-->
