# 2025年2月 学习记录

## 2.7

**今日学习：**
- [x] N叉树的遍历（前序、后序、层序）
- [x] 二叉树的最小深度（DFS vs BFS）
- [x] 完全二叉树的节点个数（利用完全二叉树性质优化）
- [x] BFS 求最短路径的优势
- [x] 二叉树的所有路径（回溯思想）
- [x] 翻转二叉树（遍历 vs 分治）
- [x] 填充每个节点的下一个右侧节点指针（三叉树遍历思维）
- [x] 二叉树展开为链表（后序位置的妙用）

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 589 | N叉树的前序遍历 | 简单 | ✅ |
| 590 | N叉树的后序遍历 | 简单 | ✅ |
| 429 | N叉树的层序遍历 | 中等 | ✅ |
| 111 | 二叉树的最小深度 | 简单 | ✅ |
| 222 | 完全二叉树的节点个数 | 简单 | ✅ |
| 257 | 二叉树的所有路径 | 简单 | ✅ |
| 226 | 翻转二叉树 | 简单 | ✅ |
| 116 | 填充每个节点的下一个右侧节点指针 | 中等 | ✅ |
| 114 | 二叉树展开为链表 | 中等 | ✅ |

**笔记：**
- **N叉树遍历框架**：
  - 与二叉树类似，只是用 `for` 循环遍历所有子节点
  - N叉树**没有中序遍历**（中序位置只对二叉树有意义）
  ```cpp
  void traverse(Node* root) {
      if(root == nullptr) return;
      // 前序位置
      for(Node* child : root->children) {
          traverse(child);
      }
      // 后序位置
  }
  ```

- **二叉树的最小深度**：
  - **DFS 方法**：遍历所有节点，在叶子节点处更新最小深度
    ```cpp
    int mindepth = INT_MAX, mydepth = 0;
    void traverse(TreeNode* root) {
        if(root == nullptr) return;
        mydepth++;  // 前序位置
        if(!root->left && !root->right) {  // 叶子节点
            mindepth = min(mindepth, mydepth);
        }
        traverse(root->left);
        traverse(root->right);
        mydepth--;  // 后序位置
    }
    ```
  - **BFS 方法**（推荐）：层序遍历，第一个遇到的叶子节点即为最小深度
    ```cpp
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        queue<TreeNode*> q;
        q.push(root);
        int depth = 1;
        while(!q.empty()) {
            int sz = q.size();
            for(int i = 0; i < sz; i++) {
                TreeNode* cur = q.front(); q.pop();
                if(!cur->left && !cur->right) return depth;
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
            depth++;
        }
        return depth;
    }
    ```
  - **BFS 优势**：找到第一个叶子节点就返回，不需要遍历整棵树
  - **注意**：叶子节点必须是左右子节点都为空的节点

- **完全二叉树的节点个数**：
  - **方法一**：普通遍历 O(N)
    ```cpp
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
    ```
  - **方法二**：利用完全二叉树性质 O(log²N)
    - **关键性质**：完全二叉树的两棵子树，至少有一棵是满二叉树
    - 满二叉树节点数 = 2^h - 1（h为高度）
    ```cpp
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        TreeNode *l = root, *r = root;
        int hl = 0, hr = 0;
        while(l) { l = l->left; hl++; }
        while(r) { r = r->right; hr++; }
        // 左右高度相等，说明是满二叉树
        if(hl == hr) return pow(2, hl) - 1;
        // 否则按普通二叉树计算
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
    ```
  - **时间复杂度分析**：
    - 每次递归只会进入左子树或右子树之一（另一个是满二叉树直接算出）
    - 递归深度 O(logN)，每层计算高度 O(logN)
    - 总复杂度 O(log²N)

- **DFS vs BFS 选择**：
  - **DFS**：适合需要遍历所有节点、或需要子树信息的问题
  - **BFS**：适合求最短路径、最小深度等"最近"问题
  - **BFS 本质**：层层扩展，第一次到达目标就是最短路径

- **二叉树的所有路径**：
  - **回溯思想**：维护当前路径 `path`，到达叶子节点时记录结果
  - **关键**：前序位置加入节点，后序位置弹出节点（回溯）
  ```cpp
  vector<string> path;
  void traverse(TreeNode* root) {
      if(root == nullptr) return;
      // 叶子节点：记录路径并返回
      if(!root->left && !root->right) {
          path.push_back(to_string(root->val));
          res.push_back(joinPath(path));
          path.pop_back();  // 回溯
          return;
      }
      // 前序位置：加入当前节点
      path.push_back(to_string(root->val));
      traverse(root->left);
      traverse(root->right);
      // 后序位置：回溯
      path.pop_back();
  }
  ```
  - **路径拼接**：用 `stringstream` 或手动拼接 `"->"`

- **翻转二叉树**：
  - **方法一：遍历思维**
    ```cpp
    void traverse(TreeNode* root) {
        if(root == nullptr) return;
        // 前序位置交换左右子节点
        swap(root->left, root->right);
        traverse(root->left);
        traverse(root->right);
    }
    ```
  - **方法二：分治思维**（推荐）
    ```cpp
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return nullptr;
        TreeNode* l = invertTree(root->left);
        TreeNode* r = invertTree(root->right);
        root->left = r;
        root->right = l;
        return root;
    }
    ```
  - **前序/后序都可以**，中序不行（会导致某些节点被翻转两次）

- **填充每个节点的下一个右侧节点指针**：
  - **方法一：层序遍历（BFS）**
    - 每层节点依次连接，最后一个节点指向 NULL
  - **方法二：递归（三叉树思维）**（推荐）
    - **核心洞察**：需要连接的不只是同父节点的兄弟，还有跨父节点的堂兄弟
    - **解决方案**：将问题转化为"连接两个相邻节点"
    ```cpp
    Node* connect(Node* root) {
        if(root == nullptr) return nullptr;
        traverse(root->left, root->right);
        return root;
    }
    void traverse(Node* node1, Node* node2) {
        if(node1 == nullptr || node2 == nullptr) return;
        // 前序位置：连接两个节点
        node1->next = node2;
        // 连接相同父节点的子节点
        traverse(node1->left, node1->right);
        traverse(node2->left, node2->right);
        // 连接跨父节点的子节点（关键！）
        traverse(node1->right, node2->left);
    }
    ```
  - **空间复杂度**：递归 O(logN)，迭代 O(N)

- **二叉树展开为链表**：
  - **关键约束**：原地修改，不能创建新节点
  - **后序位置的妙用**：先递归拉平左右子树，再进行拼接
  ```cpp
  void flatten(TreeNode* root) {
      if(root == nullptr) return;
      // 先拉平左右子树
      flatten(root->left);
      flatten(root->right);
      
      // 后序位置：左右子树已经是链表
      TreeNode* l = root->left;
      TreeNode* r = root->right;
      
      // 1. 左子树置空，右子树接上原左子树
      root->left = nullptr;
      root->right = l;
      
      // 2. 找到当前链表末尾，接上原右子树
      TreeNode* p = root;
      while(p->right != nullptr) p = p->right;
      p->right = r;
  }
  ```
  - **为什么用后序？** 需要先处理子树，获得子树信息后再操作当前节点
  - **时间 O(N)**，每个节点访问一次

- **二叉树问题的三种思维模式**：
  1. **遍历思维**：用 traverse 遍历所有节点，维护外部变量
  2. **分治思维**：定义递归函数的返回值，用子问题答案推导原问题
  3. **层序遍历**：BFS 适合按层处理或求最短路径

---

## 2.6

**今日学习：**
- [x] 二叉树的三种遍历方式（前序、中序、后序）
- [x] 二叉树的层序遍历（BFS）
- [x] 遍历思维 vs 分治思维
- [x] 后序位置的特殊性：利用子树信息
- [x] 邻接表表示树结构（无向图建树）

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 94 | 二叉树的中序遍历 | 简单 | ✅ |
| 144 | 二叉树的前序遍历 | 简单 | ✅ |
| 145 | 二叉树的后序遍历 | 简单 | ✅ |
| 102 | 二叉树的层序遍历 | 中等 | ✅ |
| 104 | 二叉树的最大深度 | 简单 | ✅ |
| 543 | 二叉树的直径 | 简单 | ✅ |
| - | 二叉树的三种遍历（邻接表） | 模板 | ✅ |

**笔记：**
- **二叉树遍历框架**：
  ```cpp
  void traverse(TreeNode* root) {
      if(root == nullptr) return;
      // 前序位置
      traverse(root->left);
      // 中序位置
      traverse(root->right);
      // 后序位置
  }
  ```

- **两种思维模式**：
  - **遍历思维**：用一个 traverse 函数遍历所有节点，在遍历过程中更新外部变量
  - **分治思维**：定义递归函数返回子问题的结果，通过子问题答案推导原问题答案

- **前序遍历**（两种写法）：
  - **遍历写法**：
    ```cpp
    vector<int> res;
    void traverse(TreeNode* root) {
        if(root == nullptr) return;
        res.push_back(root->val);  // 前序位置
        traverse(root->left);
        traverse(root->right);
    }
    ```
  - **分治写法**：
    ```cpp
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        res.push_back(root->val);
        vector<int> left = preorderTraversal(root->left);
        res.insert(res.end(), left.begin(), left.end());
        vector<int> right = preorderTraversal(root->right);
        res.insert(res.end(), right.begin(), right.end());
        return res;
    }
    ```
  - 注意：分治写法时间复杂度较高（vector 合并开销）

- **层序遍历（BFS）**：
  - **方法一**：基础 BFS
    ```cpp
    void traverse(TreeNode* root) {
        if(root == nullptr) return;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()) {
            int sz = q.size();
            vector<int> level;
            for(int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                level.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
            res.push_back(level);
            level.clear();
        }
    }
    ```
  - **方法二**：带权重/深度信息的 State 类
    ```cpp
    class State {
    public:
        TreeNode* node;
        int depth;
        State(TreeNode* n, int d) : node(n), depth(d) {}
    };
    ```
  - 适用于需要记录节点额外信息的场景（如路径权重）

- **二叉树的最大深度**：
  - **遍历思维**：维护 `depth` 和 `res`，到达叶子节点时更新最大值
    ```cpp
    int depth = 0, res = 0;
    void traverse(TreeNode* root) {
        if(root == nullptr) return;
        depth++;  // 前序位置，进入节点
        if(!root->left && !root->right) res = max(res, depth);
        traverse(root->left);
        traverse(root->right);
        depth--;  // 后序位置，离开节点
    }
    ```
  - **分治思维**（推荐）：
    ```cpp
    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        return max(leftMax, rightMax) + 1;
    }
    ```

- **二叉树的直径**：
  - **关键洞察**：直径 = 某节点的左子树最大深度 + 右子树最大深度
  - **后序位置的妙用**：在计算最大深度的同时，顺便计算直径
    ```cpp
    int maxDiameter = 0;
    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        // 后序位置：此时已知左右子树深度
        maxDiameter = max(maxDiameter, leftMax + rightMax);
        return max(leftMax, rightMax) + 1;
    }
    ```
  - 注意：直径不一定经过根节点，需要在每个节点处更新

- **二叉树通用思考过程**：
  1. 能否通过遍历一遍得到答案？
  2. 能否定义递归函数，用子问题答案推导原问题？
  3. 如果需要子树信息，优先考虑后序遍历

- **前序 vs 后序位置**：
  - **前序位置**：只能获取父节点传递的数据
  - **后序位置**：可以获取子树的返回值（子树信息）
  - **选择原则**：需要子树信息时用后序，否则前序更直观

- **动态规划、回溯、DFS 的关系**：
  - **动态规划**：关注整棵「子树」
  - **回溯算法**：关注节点间的「树枝」
  - **DFS 算法**：关注单个「节点」

- **邻接表表示树结构**：
  - **适用场景**：输入为边列表 `(u, v)` 而非指针结构时
  - **核心思想**：用无向图存储树，遍历时通过 parent 参数排除父节点
  - **数据结构**：
    ```cpp
    vector<vector<int>> tree;  // tree[i] 存储与节点 i 相邻的所有节点
    vector<int> values;        // values[i] 存储节点 i+1 的值（0-indexed）
    ```
  - **建图过程**：
    ```cpp
    tree.resize(n + 1);  // 节点编号从1开始
    for(auto& edge : edges) {
        tree[edge[0]].push_back(edge[1]);  // 双向存储
        tree[edge[1]].push_back(edge[0]);
    }
    ```
  - **遍历模板**：
    ```cpp
    void traverse(int node, int parent) {
        // 过滤出子节点（排除父节点）
        vector<int> children;
        for(int child : tree[node]) {
            if(child != parent) {
                children.push_back(child);
            }
        }
        // 前序位置
        preorder.push_back(values[node - 1]);
        // 递归左子树
        if(children.size() >= 1) traverse(children[0], node);
        // 中序位置
        inorder.push_back(values[node - 1]);
        // 递归右子树
        if(children.size() >= 2) traverse(children[1], node);
        // 后序位置
        postorder.push_back(values[node - 1]);
    }
    // 调用：traverse(1, -1)，从根节点1开始，父节点设为-1
    ```
  - **关键点**：
    - 无向图中每条边存两次，遍历时需要排除父节点
    - 节点编号从1开始时，数组大小为 `n + 1`
    - 多组测试数据时需要清空全局变量

---

## 2.5

**今日学习：**
- [x] 链表反转的递归三要素
- [x] 反转整个链表（迭代/递归）
- [x] 反转链表前N个节点
- [x] 反转链表的指定区间 [left, right]
- [x] K个一组翻转链表
- [x] 回文链表判断（三种方法）

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 206 | 反转链表 | 简单 | ✅ |
| 92 | 反转链表 II | 中等 | ✅ |
| 25 | K 个一组翻转链表 | 困难 | ✅ |
| 234 | 回文链表 | 简单 | ✅ |

**笔记：**
- **递归三要素**：
  1. **递归函数的定义是什么？** reverseN(head, n): 反转以head为头的前n个节点，返回新头节点
  2. **递归终止条件是什么？** `if (n == 1)` 只有1个节点时，不需要反转
  3. **这一层递归应该做什么？** 假设 `reverseN(head->next, n-1)` 已经正确反转了后面n-1个节点，我只需要把当前head连接到正确位置

- **反转整个链表**：
  - **迭代版**：
    ```cpp
    ListNode *pre = nullptr, *cur = head, *nxt = head->next;
    while(cur != nullptr) {
        cur->next = pre;
        pre = cur;
        cur = nxt;
        if(nxt != nullptr) nxt = nxt->next;
    }
    return pre;
    ```
  - **递归版**：
    ```cpp
    if(head == nullptr || head->next == nullptr) return head;
    ListNode* last = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return last;
    ```

- **反转前N个节点（模板）**：
  - **迭代版**（推荐）：
    ```cpp
    ListNode* reverseN(ListNode* head, int n) {
        if(!head || !head->next) return head;
        ListNode *pre = nullptr, *cur = head, *nxt = head->next;
        while(n--) {
            cur->next = pre;
            pre = cur;
            cur = nxt;
            if(nxt != nullptr) nxt = nxt->next;
        }
        head->next = cur;  // 关键：原head连接到第n+1个节点
        return pre;
    }
    ```
  - **递归版**：
    ```cpp
    ListNode* successor = nullptr;
    ListNode* reverseN(ListNode* head, int n) {
        if(n == 1) {
            successor = head->next;  // 记录第n+1个节点
            return head;
        }
        ListNode* last = reverseN(head->next, n - 1); // 假设子问题已解决
        head->next->next = head;
        head->next = successor;
        return last;
    }
    ```

- **反转链表 II（区间反转）**：
  - **递归思路**：当 `left == 1` 时，相当于反转前 `right` 个节点
  - 否则递归：`head->next = reverseBetween(head->next, left - 1, right - 1)`
  - **迭代思路**：找到区间前一个节点，反转区间内节点，重新连接

- **K个一组翻转链表**：
  ```cpp
  ListNode* reverseKGroup(ListNode* head, int k) {
      if(k == 1 || !head || !head->next) return head;
      ListNode *a = head, *b = head;
      for(int i = 0; i < k; i++) {
          if(b == nullptr) return head;  // 不足k个直接返回
          b = b->next;
      }
      ListNode* newHead = reverseN(a, k);  // 反转前k个
      a->next = reverseKGroup(b, k);       // 递归处理后面的
      return newHead;
  }
  ```
  - **关键点**：
    - 区间 `[a, b)` 包含k个待反转节点
    - 反转后 `a` 变成该组的尾节点，需要连接下一组
    - 不足k个节点时直接返回原head

- **回文链表判断（三种方法）**：
  - **方法一：转化为数组** O(n) 时间，O(n) 空间
    ```cpp
    vector<int> v;
    while(cur) { v.push_back(cur->val); cur = cur->next; }
    // 双指针判断回文
    int left = 0, right = v.size() - 1;
    while(left < right) {
        if(v[left++] != v[right--]) return false;
    }
    return true;
    ```
  - **方法二：快慢指针+反转后半部分**（推荐）O(n) 时间，O(1) 空间
    ```cpp
    // 1. 快慢指针找中点
    ListNode *fast = head, *slow = head;
    while(fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
    } // 奇数：slow是中点，偶数：slow是左中点
    
    // 2. 反转后半部分
    ListNode* head2 = reverseList(slow->next);
    
    // 3. 比较前后部分
    ListNode *p1 = head, *p2 = head2;
    while(p2) { // p2更短（奇数时）
        if(p1->val != p2->val) return false;
        p1 = p1->next; p2 = p2->next;
    }
    
    // 4. 复原链表（可选）
    slow->next = reverseList(head2);
    return true;
    ```
  - **方法三：递归（后序遍历）** O(n) 时间，O(n) 空间（栈空间）
    ```cpp
    ListNode* left;
    bool res = true;
    void traverse(ListNode* right) {
        if(!right) return;
        traverse(right->next); // 递归到最右边
        // 后序位置：right从右向左，left从左向右
        if(left->val != right->val) res = false;
        left = left->next;
    }
    ```
  - **关键点**：
    - 快慢指针找中点：`while(fast->next && fast->next->next)`
    - 奇数链表：slow是中点，偶数链表：slow是左中点
    - 比较时以后半部分(p2)为准，因为它可能更短

- **链表反转的常见错误**：
  - ❌ 忘记处理 `nxt` 为空的情况
  - ❌ 迭代中 `if(nxt != nullptr)` 写成 `while`
  - ❌ 反转前N个节点后忘记连接后续节点 `head->next = cur`
  - ✅ 想不清楚就画图，用 `1->2->3->4` 反转前3个试试

- **迭代 vs 递归选择**：
  - **迭代**：空间 O(1)，逻辑直观，适合面试手写
  - **递归**：代码简洁，但有栈空间开销 O(n)
  - **建议**：掌握迭代版作为主力，递归版理解思路

---

## 2.4

**今日学习：**
- [x] Fisher-Yates 洗牌算法（从后往前/从前往后）
- [x] 蓄水池抽样算法（Reservoir Sampling）
- [x] 前缀和 + 二分查找实现按权重随机选择
- [x] 二分查找的两种实现：STL `lower_bound` vs 手写
- [x] 随机算法的概率证明
- [x] C++ 随机数生成器：`rand()` vs `<random>` 库
- [x] 双指针技巧：对撞指针在有序数组中的应用
- [x] 矩阵操作：转置、对角线处理、坐标映射
- [x] 一维数组模拟：将二维问题降维处理
- [x] 字符串遍历：按列优先 vs 按行优先

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 382 | 链表随机节点 | 中等 | ✅ |
| 384 | 打乱数组 | 中等 | ✅ |
| 528 | 按权重随机选择 | 中等 | ✅ |
| 398 | 随机数索引 | 中等 | ✅ |
| 977 | 有序数组的平方 | 简单 | ✅ |
| 867 | 转置矩阵 | 简单 | ✅ |
| 1329 | 将矩阵按对角线排序 | 中等 | ✅ |
| 1260 | 二维网格迁移 | 中等 | ✅ |
| 14 | 最长公共前缀 | 简单 | ✅ |

**笔记：**
- **Fisher-Yates 洗牌算法**：
  - **从后往前**（推荐）：
    ```cpp
    for (int i = n-1; i > 0; i--) {
        int j = rand() % (i + 1);  // [0, i]
        swap(arr[i], arr[j]);
    }
    ```
  - **从前往后**：
    ```cpp
    for (int i = 0; i < n; i++) {
        int j = i + rand() % (n - i);  // [i, n-1]
        swap(arr[i], arr[j]);
    }
    ```
  - 核心思想：逐步缩小未处理区域，保证每种排列概率相等（1/n!）
  - 时间复杂度 O(n)，空间复杂度 O(1)
  - ⚠️ 注意：随机范围是 `i + 1` 而不是固定的 `n - 1`

- **蓄水池抽样算法**：
  - 用于在**不知道数据总量**或**无法随机访问**的情况下等概率随机选择
  - 核心思想：遍历时第 i 个元素以 `1/i` 概率被选中
  - ```cpp
    int count = 0, result;
    while (curr) {
        count++;
        if (rand() % count == 0) result = curr->val;
        curr = curr->next;
    }
    ```
  - **概率证明**：
    - 第 k 个元素被选中概率 = (1/k) × (k/(k+1)) × ... × ((n-1)/n) = 1/n
    - 即：以 1/k 概率选中，后续不被替换的概率为 k/n
  - 适用场景：链表随机节点、流式数据随机采样
  - 时间 O(n)，空间 O(1)

- **按权重随机选择（前缀和+二分）**：
  - 步骤：
    1. 构建前缀和数组：`w = [1, 3, 2]` → `preSum = [1, 4, 6]`
    2. 生成 `[1, total]` 的随机数
    3. 二分查找第一个 `>= target` 的位置
  - 区间映射：权重越大，对应区间越长，被命中概率越高
    - 索引0: [1, 1] 长度1
    - 索引1: [2, 4] 长度3
    - 索引2: [5, 6] 长度2
  - 时间：构造 O(n)，pickIndex O(log n)

- **二分查找实现对比**：
  - **使用 `lower_bound`**（推荐熟练时使用）：
    - 优点：代码简洁，STL 可靠
    - 缺点：需要记住语义（`>=` 还是 `>`）
    ```cpp
    return lower_bound(preSum.begin(), preSum.end(), target) - preSum.begin();
    ```
  - **手写二分**（推荐不熟练时使用）：
    - 优点：逻辑清晰，完全可控
    - 缺点：容易写错边界
    ```cpp
    int left = 0, right = n - 1;
    while (left <= right) { 
        int mid = left + (right - left) / 2;
        if (preSum[mid] < target) left = mid + 1;
        else right = mid - 1; 
    }
    return left;
    ```
  - **比赛建议**：用自己最有把握的方式，保证不出错比代码简洁更重要

- **C++ 随机数生成器对比**：
  - **`rand()` 的问题**：
    - 伪随机数质量不佳，某些编译器实现可能产生固定序列
    - 依赖全局状态，线程不安全
    - 随机范围有限（通常为 `RAND_MAX = 32767`）
    - LeetCode 环境下可能导致部分测试用例失败
  - **`<random>` 库**（推荐）：
    ```cpp
    class Solution {
    private:
        mt19937 gen;  // Mersenne Twister 生成器
    public:
        Solution() : gen(random_device{}()) {}  // 真随机种子初始化
        
        int getRandom(int n) {
            uniform_int_distribution<int> dis(0, n - 1);
            return dis(gen);
        }
    };
    ```
  - **关键组件**：
    - `random_device{}`：真随机数种子（基于硬件）
    - `mt19937`：高质量伪随机数生成器（周期 2^19937-1）
    - `uniform_int_distribution`：均匀分布，确保每个数概率相等
  - **优势**：
    - 随机质量高，符合统计学分布
    - 线程安全（每个对象独立状态）
    - 可重现（可用固定种子调试）
  - **使用建议**：
    - ✅ 竞赛/面试：优先使用 `<random>`
    - ⚠️ 简单题目：`rand()` 可能够用，但注意测试环境
    - 🔧 调试技巧：`mt19937 gen(42);` 使用固定种子

- **有序数组的平方**：
  - **双指针对撞**：由于原数组有序，负数平方后递减，正数平方后递增
  - 从两端向中间比较绝对值，较大值从后往前填入结果数组
  - ```cpp
    int i = 0, j = n - 1, p = n - 1;
    while(i <= j) {
        if(abs(nums[i]) >= abs(nums[j])) {
            res[p--] = nums[i] * nums[i];
            i++;
        } else {
            res[p--] = nums[j] * nums[j];
            j--;
        }
    }
    ```
  - 时间 O(n)，优于排序的 O(n log n)
  - 核心：利用原数组的有序性，避免排序

- **转置矩阵**：
  - **方法一**：直接转置 `res[j][i] = matrix[i][j]`
    - 按行遍历原矩阵，按列填入新矩阵
  - **方法二**：按列优先遍历（思维转换）
    ```cpp
    for(int j = 0; j < n; j++)      // 遍历每一列
        for(int i = 0; i < m; i++)  // 遍历该列的每一行
            res[j][i] = matrix[i][j]; // 第j列变成第j行
    ```
  - 注意：转置后维度变化 `m×n → n×m`
  - 时间 O(m×n)，空间 O(n×m)

- **将矩阵按对角线排序**：
  - **关键观察**：同一对角线上的元素满足 `i - j = 常数`
  - **方法一**：哈希表 + `list`
    - `list` 的 `sort()` 函数：O(n log n)
    - `pop_front()` / `pop_back()`：O(1)
    - 适合频繁删除操作
  - **方法二**：哈希表 + `vector` + 索引（推荐）
    ```cpp
    unordered_map<int, vector<int>> mp;
    unordered_map<int, int> idx; // 记录每条对角线的当前索引
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            mp[i - j].push_back(mat[i][j]);
        }
    }
    for(auto& [key, vec] : mp) {
        sort(vec.begin(), vec.end());
        idx[key] = 0;
    }
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            res[i][j] = mp[i - j][idx[i - j]++];
        }
    }
    ```
  - **对角线分类**：
    - 主对角线及以上：`i - j <= 0`
    - 主对角线以下：`i - j > 0`
  - 时间 O(m×n×log(min(m,n)))，每条对角线最多 min(m,n) 个元素

- **二维网格迁移**：
  - **方法一**：暴力模拟 k 次移动
    - 每次移动：最后一个元素移到第一个位置，其余元素右移
    - 时间 O(k×m×n)，空间 O(m×n)
  - **方法二**：一维数组映射（推荐）
    - **核心思想**：将二维数组展平为一维，右移 k 位后再映射回二维
    - ```cpp
    int oldPos = i * n + j;           // 原位置
    int newPos = (oldPos + k) % total; // 新位置（取模处理循环）
    res[newPos / n][newPos % n] = grid[i][j];
    ```
  - **优化**：`k %= total` 避免重复计算
  - 时间 O(m×n)，空间 O(m×n)
  - **坐标映射公式**：
    - 一维 → 二维：`(idx / n, idx % n)`
    - 二维 → 一维：`i * n + j`

- **最长公共前缀**：
  - **按列遍历**：逐列比较所有字符串的对应字符
  - ```cpp
    int minLen = INT_MAX;
    for(auto& str : strs) minLen = min(minLen, (int)str.size());
    
    for(int j = 0; j < minLen; j++) {
        char c = strs[0][j];
        for(int i = 1; i < strs.size(); i++) {
            if(strs[i][j] != c) {
                return strs[0].substr(0, j);
            }
        }
    }
    return strs[0].substr(0, minLen);
    ```
  - **注意事项**：
    - `str.size()` 返回 `size_t`（无符号类型），与 `int` 比较需强制转换
    - `substr(pos, len)`：从 pos 开始截取 len 个字符
    - 边界条件：空数组、单字符串、无公共前缀
  - 时间 O(S)，S 为所有字符串的字符总数
  - 优化：先找最短字符串，避免越界

- **矩阵问题的通用技巧**：
  - **降维处理**：二维 ⟺ 一维（适用于规律性操作）
  - **坐标映射**：`(i, j) ⟺ i * n + j`
  - **对角线识别**：`i - j`（主对角线）、`i + j`（副对角线）
  - **遍历顺序**：按行、按列、按对角线根据问题选择
  - **空间优化**：能否原地修改或使用 O(1) 额外空间

- **类型转换注意事项**：
  - `size_t` 是无符号类型，与有符号类型比较时需要转换
  - `static_cast<int>(str.size())` 或 `(int)str.size()`
  - 避免无符号整数下溢：`size_t a = 0; a - 1` 会变成很大的数

- **常见错误**：
  - ❌ `rand() % (n - 1)` → 最后一个位置无法被选中
  - ❌ `preSum[target]` → target 是数值不是索引，会越界
  - ❌ `while (left <= right)` 配合 `right = mid` → 死循环
  - ❌ 每次调用都创建新的 `uniform_int_distribution` 对象 → 性能低但正确
  - ✅ `rand() % (i + 1)` → 范围 [0, i]
  - ✅ `preSum[mid] < target` → 比较数值
  - ✅ `while (left < right)` 配合 `right = mid` → 查找第一个位置
  - ✅ 将 `mt19937` 作为类成员变量，保持状态连续性

---

## 2.3

**今日学习：**
- [x] 二分查找算法框架
- [x] 二分查找的变体：寻找左侧边界
- [x] 转化问题：最值问题 → 二分搜索
- [x] 单调性判断：f(x) 关于 x 的单调性
- [x] 矩阵重塑：坐标映射技巧

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 704 | 二分查找 | 简单 | ✅ |
| 875 | 爱吃香蕉的珂珂 | 中等 | ✅ |
| 1011 | 在 D 天内送达包裹的能力 | 中等 | ✅ |
| LCR 172 | 统计目标成绩的出现次数 | 简单 | ✅ |
| 410 | 分割数组的最大值 | 困难 | ✅ |
| 566 | 重塑矩阵 | 简单 | ✅ |

**笔记：**
- **二分查找基础框架**：
  ```cpp
  int left = 0, right = nums.size() - 1;
  while(left <= right) { // 左闭右闭区间 [left, right]
      int mid = left + (right - left) / 2;
      if(nums[mid] == target) return mid;
      else if(nums[mid] < target) left = mid + 1;
      else if(nums[mid] > target) right = mid - 1;
  }
  return -1;
  ```
- **寻找左侧边界**（找满足条件的最小值）：
  - 当 `f(mid) <= target` 时，`right = mid - 1`（收缩右边界）
  - 当 `f(mid) > target` 时，`left = mid + 1`
  - 最终返回 `left`
- 当目标元素 target 不存在数组 nums 中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读：(都是等价的)
  - 1、返回的这个值是 nums 中大于等于 target 的最小元素索引。
  - 2、返回的这个值是 target 应该插入在 nums 中的索引位置。
  - 3、返回的这个值是 nums 中小于 target 的元素个数。
- **爱吃香蕉的珂珂**：
  - 定义 `f(x)` 为以速度 x 吃完所有香蕉需要的小时数
  - `f(x)` 随 x 增加而**单调递减**
  - 目标：找最小的 x 使得 `f(x) <= h`
  - 搜索空间：`[1, max(piles)]` 或 `[1, 1e9]`
  - 注意：`piles[i] / x` 向上取整 = `(piles[i] + x - 1) / x` 或判断余数
- **在 D 天内送达包裹的能力**：
  - 定义 `f(x)` 为运载能力为 x 时需要的天数
  - `f(x)` 随 x 增加而**单调递减**
  - 目标：找最小的 x 使得 `f(x) <= days`
  - 搜索空间：`[max(weights), sum(weights)]`
  - 关键：`left` 初始化为最大重量（船至少能装下最重的包裹）
- **分割数组的最大值**：
  - **问题转化**：与"在 D 天内送达包裹"完全一样的思路
  - 定义 `f(x)` 为当子数组和的最大值为 x 时，需要的子数组个数
  - `f(x)` 随 x 增加而**单调递减**
  - 目标：找最小的 x 使得 `f(x) <= k`
  - 搜索空间：`[max(nums), sum(nums)]`
  - 核心：将"最小化最大值"转化为二分搜索
- **重塑矩阵**：
  - **方法一**：通过一维数组中转，空间复杂度 O(m*n)
  - **方法二**：数学映射，O(1) 额外空间（推荐）
    - 一维索引 `i` → 原矩阵：`mat[i/n][i%n]`
    - 一维索引 `i` → 新矩阵：`res[i/c][i%c]`
  - 关键：判断 `r * c != m * n` 时返回原矩阵
- **二分查找的本质**：
  - 在单调函数上寻找边界
  - 将"求最值"问题转化为"判定"问题
  - 关键是找到单调性并正确定义 `f(x)`

---

## 2.2

**今日学习：**
- [x] 滑动窗口算法框架
- [x] 滑动窗口的四大应用场景
- [x] 哈希表记录窗口内字符频率
- [x] 子数组问题的转化思维

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 3 | 无重复字符的最长子串 | 中等 | ✅ |
| 76 | 最小覆盖子串 | 困难 | ✅ |
| 438 | 找到字符串中所有字母异位词 | 中等 | ✅ |
| 567 | 字符串的排列 | 中等 | ✅ |
| 1658 | 将 x 减到 0 的最小操作数 | 中等 | ✅ |

**笔记：**
- **滑动窗口框架**：
  ```cpp
  int left = 0, right = 0;
  while (right < s.size()) {
      // 扩大窗口
      window.add(s[right]);
      right++;
      
      while (window needs shrink) {
          // 缩小窗口
          window.remove(s[left]);
          left++;
      }
  }
  ```
- **最小覆盖子串**：
  - 用 `need` 记录目标字符频率，`window` 记录窗口内字符频率
  - `valid` 记录窗口中满足 `need` 条件的字符种类数
  - 当 `valid == need.size()` 时更新最小长度
  - 窗口收缩条件：满足覆盖要求时
- **字符串的排列**：
  - 与最小覆盖子串类似，但要求窗口大小固定为 `s1.length()`
  - 当 `right - left >= n` 时判断是否满足条件并收缩窗口
  - **关键**：必须在窗口大小恰好为 n 且字符频率匹配时返回 true
  - **找所有字母异位词**：
  - 在固定窗口大小 `p.size()` 内找所有满足条件的起始位置
  - 每次窗口满足条件时记录 `left` 索引
- **无重复字符的最长子串**：
  - 窗口收缩条件：`window[c] > 1`（出现重复字符）
  - 收缩后保证窗口内无重复，然后更新最大长度
- **将 x 减到 0 的最小操作数**：
  - **转化思维**：从两端删除和为 x ⟺ 保留中间和为 `sum - x` 的最长子数组
  - 用滑动窗口找和为 `target = sum - x` 的最长子数组
  - 答案为 `n - maxLen`（若不存在返回 -1）
- **滑动窗口 vs 双指针**：
  - 滑动窗口适合"连续子数组/子串"问题
  - 双指针更通用，可处理排序数组、链表等

---

## 2.1

**今日学习：**
- [x] 双指针技巧：对撞指针
- [x] 贪心算法：移动较小边界
- [x] 优先队列（小顶堆）+ BFS：接雨水II
- [x] 计数排序：适用于值域较小的场景
- [x] 三指针技巧：荷兰国旗问题

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 11 | 盛最多水的容器 | 中等 | ✅ |
| 42 | 接雨水 | 困难 | ✅ |
| 75 | 颜色分类 | 中等 | ✅ |
| 88 | 合并两个有序数组 | 简单 | ✅ |
| 407 | 接雨水 II | 困难 | ✅ |

**笔记：**
- 盛最多水的容器：双指针对撞，每次移动高度较小的指针（贪心思想），因为移动较高的指针不可能得到更大面积
- 接雨水三种方法：
  - 暴力：每个位置找左右最高值，O(n²)
  - 备忘录：预处理左右最高值数组，O(n) 时间 O(n) 空间（推荐）
  - 双指针：动态维护 l_max 和 r_max，O(n) 时间 O(1) 空间
- 接雨水II（三维版本）：
  - 核心思想：水桶原理 + 从外向内 BFS
  - 用优先队列维护当前最低边界点（小顶堆）
  - 积水量 = max(0, 围栏高度 - 当前高度)
  - 新边界高度 = max(围栏高度, 实际地面高度)
- 颜色分类（荷兰国旗问题）：
  - 方法一：计数排序，统计每个颜色出现次数后重新填充，O(n) 时间 O(1) 空间
  - 方法二：三指针，p0 指向 0 区间末尾，p2 指向 2 区间开头，p 遍历，交换 0 后 p++，交换 2 后 p 不动（因为交换来的元素未处理）
- 合并两个有序数组：从后往前双指针，避免覆盖 nums1 的有效元素

---

<!-- 模板
## 2.XX

**今日学习：**
- [ ] 

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| | | | |

**笔记：**
- 
-->
