# 2025年2月 学习记录

## 2.4

**今日学习：**
- [x] Fisher-Yates 洗牌算法（从后往前/从前往后）
- [x] 蓄水池抽样算法（Reservoir Sampling）
- [x] 前缀和 + 二分查找实现按权重随机选择
- [x] 二分查找的两种实现：STL `lower_bound` vs 手写
- [x] 随机算法的概率证明
- [x] C++ 随机数生成器：`rand()` vs `<random>` 库

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 382 | 链表随机节点 | 中等 | ✅ |
| 384 | 打乱数组 | 中等 | ✅ |
| 528 | 按权重随机选择 | 中等 | ✅ |
| 398 | 随机数索引 | 中等 | ✅ |

**笔记：**
- **Fisher-Yates 洗牌算法**：
  - **从后往前**（推荐）：
    ```cpp
    for (int i = n-1; i > 0; i--) {
        int j = rand() % (i + 1);  // [0, i]
        swap(arr[i], arr[j]);
    }
    ```
  - **从前往后**：
    ```cpp
    for (int i = 0; i < n; i++) {
        int j = i + rand() % (n - i);  // [i, n-1]
        swap(arr[i], arr[j]);
    }
    ```
  - 核心思想：逐步缩小未处理区域，保证每种排列概率相等（1/n!）
  - 时间复杂度 O(n)，空间复杂度 O(1)
  - ⚠️ 注意：随机范围是 `i + 1` 而不是固定的 `n - 1`

- **蓄水池抽样算法**：
  - 用于在**不知道数据总量**或**无法随机访问**的情况下等概率随机选择
  - 核心思想：遍历时第 i 个元素以 `1/i` 概率被选中
  - ```cpp
    int count = 0, result;
    while (curr) {
        count++;
        if (rand() % count == 0) result = curr->val;
        curr = curr->next;
    }
    ```
  - **概率证明**：
    - 第 k 个元素被选中概率 = (1/k) × (k/(k+1)) × ... × ((n-1)/n) = 1/n
    - 即：以 1/k 概率选中，后续不被替换的概率为 k/n
  - 适用场景：链表随机节点、流式数据随机采样
  - 时间 O(n)，空间 O(1)

- **按权重随机选择（前缀和+二分）**：
  - 步骤：
    1. 构建前缀和数组：`w = [1, 3, 2]` → `preSum = [1, 4, 6]`
    2. 生成 `[1, total]` 的随机数
    3. 二分查找第一个 `>= target` 的位置
  - 区间映射：权重越大，对应区间越长，被命中概率越高
    - 索引0: [1, 1] 长度1
    - 索引1: [2, 4] 长度3
    - 索引2: [5, 6] 长度2
  - 时间：构造 O(n)，pickIndex O(log n)

- **二分查找实现对比**：
  - **使用 `lower_bound`**（推荐熟练时使用）：
    - 优点：代码简洁，STL 可靠
    - 缺点：需要记住语义（`>=` 还是 `>`）
    ```cpp
    return lower_bound(preSum.begin(), preSum.end(), target) - preSum.begin();
    ```
  - **手写二分**（推荐不熟练时使用）：
    - 优点：逻辑清晰，完全可控
    - 缺点：容易写错边界
    ```cpp
    int left = 0, right = n - 1;
    while (left <= right) { 
        int mid = left + (right - left) / 2;
        if (preSum[mid] < target) left = mid + 1;
        else right = mid - 1; 
    }
    return left;
    ```
  - **比赛建议**：用自己最有把握的方式，保证不出错比代码简洁更重要

- **C++ 随机数生成器对比**：
  - **`rand()` 的问题**：
    - 伪随机数质量不佳，某些编译器实现可能产生固定序列
    - 依赖全局状态，线程不安全
    - 随机范围有限（通常为 `RAND_MAX = 32767`）
    - LeetCode 环境下可能导致部分测试用例失败
  - **`<random>` 库**（推荐）：
    ```cpp
    class Solution {
    private:
        mt19937 gen;  // Mersenne Twister 生成器
    public:
        Solution() : gen(random_device{}()) {}  // 真随机种子初始化
        
        int getRandom(int n) {
            uniform_int_distribution<int> dis(0, n - 1);
            return dis(gen);
        }
    };
    ```
  - **关键组件**：
    - `random_device{}`：真随机数种子（基于硬件）
    - `mt19937`：高质量伪随机数生成器（周期 2^19937-1）
    - `uniform_int_distribution`：均匀分布，确保每个数概率相等
  - **优势**：
    - 随机质量高，符合统计学分布
    - 线程安全（每个对象独立状态）
    - 可重现（可用固定种子调试）
  - **使用建议**：
    - ✅ 竞赛/面试：优先使用 `<random>`
    - ⚠️ 简单题目：`rand()` 可能够用，但注意测试环境
    - 🔧 调试技巧：`mt19937 gen(42);` 使用固定种子

- **常见错误**：
  - ❌ `rand() % (n - 1)` → 最后一个位置无法被选中
  - ❌ `preSum[target]` → target 是数值不是索引，会越界
  - ❌ `while (left <= right)` 配合 `right = mid` → 死循环
  - ❌ 每次调用都创建新的 `uniform_int_distribution` 对象 → 性能低但正确
  - ✅ `rand() % (i + 1)` → 范围 [0, i]
  - ✅ `preSum[mid] < target` → 比较数值
  - ✅ `while (left < right)` 配合 `right = mid` → 查找第一个位置
  - ✅ 将 `mt19937` 作为类成员变量，保持状态连续性

---

## 2.3

**今日学习：**
- [x] 二分查找算法框架
- [x] 二分查找的变体：寻找左侧边界
- [x] 转化问题：最值问题 → 二分搜索
- [x] 单调性判断：f(x) 关于 x 的单调性
- [x] 矩阵重塑：坐标映射技巧

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 704 | 二分查找 | 简单 | ✅ |
| 875 | 爱吃香蕉的珂珂 | 中等 | ✅ |
| 1011 | 在 D 天内送达包裹的能力 | 中等 | ✅ |
| LCR 172 | 统计目标成绩的出现次数 | 简单 | ✅ |
| 410 | 分割数组的最大值 | 困难 | ✅ |
| 566 | 重塑矩阵 | 简单 | ✅ |

**笔记：**
- **二分查找基础框架**：
  ```cpp
  int left = 0, right = nums.size() - 1;
  while(left <= right) { // 左闭右闭区间 [left, right]
      int mid = left + (right - left) / 2;
      if(nums[mid] == target) return mid;
      else if(nums[mid] < target) left = mid + 1;
      else if(nums[mid] > target) right = mid - 1;
  }
  return -1;
  ```
- **寻找左侧边界**（找满足条件的最小值）：
  - 当 `f(mid) <= target` 时，`right = mid - 1`（收缩右边界）
  - 当 `f(mid) > target` 时，`left = mid + 1`
  - 最终返回 `left`
- 当目标元素 target 不存在数组 nums 中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读：(都是等价的)
  - 1、返回的这个值是 nums 中大于等于 target 的最小元素索引。
  - 2、返回的这个值是 target 应该插入在 nums 中的索引位置。
  - 3、返回的这个值是 nums 中小于 target 的元素个数。
- **爱吃香蕉的珂珂**：
  - 定义 `f(x)` 为以速度 x 吃完所有香蕉需要的小时数
  - `f(x)` 随 x 增加而**单调递减**
  - 目标：找最小的 x 使得 `f(x) <= h`
  - 搜索空间：`[1, max(piles)]` 或 `[1, 1e9]`
  - 注意：`piles[i] / x` 向上取整 = `(piles[i] + x - 1) / x` 或判断余数
- **在 D 天内送达包裹的能力**：
  - 定义 `f(x)` 为运载能力为 x 时需要的天数
  - `f(x)` 随 x 增加而**单调递减**
  - 目标：找最小的 x 使得 `f(x) <= days`
  - 搜索空间：`[max(weights), sum(weights)]`
  - 关键：`left` 初始化为最大重量（船至少能装下最重的包裹）
- **分割数组的最大值**：
  - **问题转化**：与"在 D 天内送达包裹"完全一样的思路
  - 定义 `f(x)` 为当子数组和的最大值为 x 时，需要的子数组个数
  - `f(x)` 随 x 增加而**单调递减**
  - 目标：找最小的 x 使得 `f(x) <= k`
  - 搜索空间：`[max(nums), sum(nums)]`
  - 核心：将"最小化最大值"转化为二分搜索
- **重塑矩阵**：
  - **方法一**：通过一维数组中转，空间复杂度 O(m*n)
  - **方法二**：数学映射，O(1) 额外空间（推荐）
    - 一维索引 `i` → 原矩阵：`mat[i/n][i%n]`
    - 一维索引 `i` → 新矩阵：`res[i/c][i%c]`
  - 关键：判断 `r * c != m * n` 时返回原矩阵
- **二分查找的本质**：
  - 在单调函数上寻找边界
  - 将"求最值"问题转化为"判定"问题
  - 关键是找到单调性并正确定义 `f(x)`

---

## 2.2

**今日学习：**
- [x] 滑动窗口算法框架
- [x] 滑动窗口的四大应用场景
- [x] 哈希表记录窗口内字符频率
- [x] 子数组问题的转化思维

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 3 | 无重复字符的最长子串 | 中等 | ✅ |
| 76 | 最小覆盖子串 | 困难 | ✅ |
| 438 | 找到字符串中所有字母异位词 | 中等 | ✅ |
| 567 | 字符串的排列 | 中等 | ✅ |
| 1658 | 将 x 减到 0 的最小操作数 | 中等 | ✅ |

**笔记：**
- **滑动窗口框架**：
  ```cpp
  int left = 0, right = 0;
  while (right < s.size()) {
      // 扩大窗口
      window.add(s[right]);
      right++;
      
      while (window needs shrink) {
          // 缩小窗口
          window.remove(s[left]);
          left++;
      }
  }
  ```
- **最小覆盖子串**：
  - 用 `need` 记录目标字符频率，`window` 记录窗口内字符频率
  - `valid` 记录窗口中满足 `need` 条件的字符种类数
  - 当 `valid == need.size()` 时更新最小长度
  - 窗口收缩条件：满足覆盖要求时
- **字符串的排列**：
  - 与最小覆盖子串类似，但要求窗口大小固定为 `s1.length()`
  - 当 `right - left >= n` 时判断是否满足条件并收缩窗口
  - **关键**：必须在窗口大小恰好为 n 且字符频率匹配时返回 true
  - **找所有字母异位词**：
  - 在固定窗口大小 `p.size()` 内找所有满足条件的起始位置
  - 每次窗口满足条件时记录 `left` 索引
- **无重复字符的最长子串**：
  - 窗口收缩条件：`window[c] > 1`（出现重复字符）
  - 收缩后保证窗口内无重复，然后更新最大长度
- **将 x 减到 0 的最小操作数**：
  - **转化思维**：从两端删除和为 x ⟺ 保留中间和为 `sum - x` 的最长子数组
  - 用滑动窗口找和为 `target = sum - x` 的最长子数组
  - 答案为 `n - maxLen`（若不存在返回 -1）
- **滑动窗口 vs 双指针**：
  - 滑动窗口适合"连续子数组/子串"问题
  - 双指针更通用，可处理排序数组、链表等

---

## 2.1

**今日学习：**
- [x] 双指针技巧：对撞指针
- [x] 贪心算法：移动较小边界
- [x] 优先队列（小顶堆）+ BFS：接雨水II
- [x] 计数排序：适用于值域较小的场景
- [x] 三指针技巧：荷兰国旗问题

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 11 | 盛最多水的容器 | 中等 | ✅ |
| 42 | 接雨水 | 困难 | ✅ |
| 75 | 颜色分类 | 中等 | ✅ |
| 88 | 合并两个有序数组 | 简单 | ✅ |
| 407 | 接雨水 II | 困难 | ✅ |

**笔记：**
- 盛最多水的容器：双指针对撞，每次移动高度较小的指针（贪心思想），因为移动较高的指针不可能得到更大面积
- 接雨水三种方法：
  - 暴力：每个位置找左右最高值，O(n²)
  - 备忘录：预处理左右最高值数组，O(n) 时间 O(n) 空间（推荐）
  - 双指针：动态维护 l_max 和 r_max，O(n) 时间 O(1) 空间
- 接雨水II（三维版本）：
  - 核心思想：水桶原理 + 从外向内 BFS
  - 用优先队列维护当前最低边界点（小顶堆）
  - 积水量 = max(0, 围栏高度 - 当前高度)
  - 新边界高度 = max(围栏高度, 实际地面高度)
- 颜色分类（荷兰国旗问题）：
  - 方法一：计数排序，统计每个颜色出现次数后重新填充，O(n) 时间 O(1) 空间
  - 方法二：三指针，p0 指向 0 区间末尾，p2 指向 2 区间开头，p 遍历，交换 0 后 p++，交换 2 后 p 不动（因为交换来的元素未处理）
- 合并两个有序数组：从后往前双指针，避免覆盖 nums1 的有效元素

---

<!-- 模板
## 2.XX

**今日学习：**
- [ ] 

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| | | | |

**笔记：**
- 
-->
