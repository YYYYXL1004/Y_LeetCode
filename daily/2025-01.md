# 2025年1月 学习记录

## 1.28

**今日学习：**
- [x] 双指针技巧：快慢指针去重
- [x] 数组/链表去重的对应关系
- [x] nSum 问题通用模板（排序 + 递归降维）
- [x] 哈希表经典应用：两数之和、字母异位词

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 1 | 两数之和 | 简单 | ✅ |
| 5 | 最长回文子串 | 中等 | ✅ |
| 15 | 三数之和 | 中等 | ✅ |
| 18 | 四数之和 | 中等 | ✅ |
| 26 | 删除有序数组中的重复项 | 简单 | ✅ |
| 27 | 移除元素 | 简单 | ✅ |
| 49 | 字母异位词分组 | 中等 | ✅ |
| 167 | 两数之和 II - 输入有序数组 | 中等 | ✅ |
| 242 | 有效的字母异位词 | 简单 | ✅ |
| 283 | 移动零 | 简单 | ✅ |
| 344 | 反转字符串 | 简单 | ✅ |
| 387 | 字符串中的第一个唯一字符 | 简单 | ✅ |

**笔记：**
- 求满足条件的子数组，一般是前缀和、滑动窗口，经常结合哈希表
- 区间操作元素，一般是前缀和、差分数组、线段树
- 数组有序，主要是双指针技巧，更大概率会用到二分搜索
- 数组去重模板：slow 指向不重复序列末尾，fast 遍历数组，遇到不同值时 `slow++; nums[slow] = nums[fast]`
- 链表去重与数组去重对应：`slow->next = fast` 对应 `nums[slow] = nums[fast]`，`slow = slow->next` 对应 `slow++`
- 链表去重最后需要 `slow->next = nullptr` 断开尾部
- 两数之和：返回下标用哈希表，返回值可排序+双指针
- nSum 通用模板：排序后递归降维，n > 2 时固定一个数转为 (n-1)Sum，n = 2 时双指针
- nSum 去重：三个位置都要跳过重复值，`while(i < sz - 1 && nums[i] == nums[i+1]) i++`
- 字母异位词判断：排序后比较，或统计字符频率
- 字母异位词分组：用排序后的字符串或字符频率编码作为哈希表的 key

## 1.27

**今日学习：**
- [x] 栈的经典应用：括号匹配与路径简化

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 20 | 有效的括号 | 简单 | ✅ |
| 71 | 简化路径 | 中等 | ✅ |

**笔记：**
- 栈的核心特性：后进先出（LIFO），适合处理"最近匹配"或"回溯"问题
- 括号匹配：左括号入栈，遇到右括号时与栈顶匹配，匹配成功则弹出
- 路径简化：用栈维护目录层级，`..` 弹出栈顶（返回上级），`.` 和空字符串跳过
- 用 `vector` 模拟栈：既有栈的 `push_back/pop_back`，又方便最后顺序遍历
- `stringstream` + `getline(ss, token, '/')` 可按指定分隔符分割字符串
- 注意：单引号 `'x'` 只能表示单个字符，字符串必须用双引号 `".."`

---

## 1.26

**今日学习：**
- [x] 循环队列/双端队列设计
- [x] 动态规划 + 二分查找优化

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 622 | 设计循环队列 | 中等 | ✅ |
| 641 | 设计循环双端队列 | 中等 | ✅ |
| 1235 | 规划兼职工作 | 困难 | ✅ |

**笔记：**
- 循环队列使用 `capacity = k + 1` 的技巧，浪费一个空间来区分空和满
- 环形数组移动技巧：
  - 下一个位置：`(cur + 1) % capacity`
  - 上一个位置：`(cur - 1 + capacity) % capacity`
- 判空：`front == rear`；判满：`(rear + 1) % capacity == front`
- 规划兼职工作：按结束时间排序 + DP + 二分查找优化
- `dp[i]` 表示考虑前 i 个工作的最大收益，转移时二分查找不冲突的上一个工作
- 使用 `upper_bound` 找第一个结束时间 > 当前开始时间的位置，其前一个即为合法状态

---

## 1.25

**今日学习：**
- [x] 螺旋矩阵遍历技巧
- [x] 矩阵原地旋转
- [x] 字符串原地操作技巧

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 48 | 旋转图像 | 中等 | ✅ |
| 54 | 螺旋矩阵 | 中等 | ✅ |
| 59 | 螺旋矩阵 II | 中等 | ✅ |
| 151 | 反转字符串中的单词 | 中等 | ✅ |

**笔记：**
- 螺旋矩阵遍历：维护四个边界 `upper/lower/left/right`，按顺时针方向遍历并收缩边界
- 矩阵顺时针旋转90°：先沿主对角线镜像翻转，再反转每一行
- 矩阵逆时针旋转90°：
  - 方法一：沿主对角线镜像翻转 + 反转每一列
  - 方法二（推荐）：沿副对角线翻转 + 反转每一行
  - 反转每一行比反转列方便：`for(auto &row : matrix) reverse(row.begin(), row.end());`
- 字符串原地去除多余空格：快慢指针，慢指针记录有效位置，快指针遍历（见 [151.反转字符串中的单词.cpp](../151.反转字符串中的单词.cpp)）
- 反转字符串中的单词：先整体反转，再逐词反转（或先去空格再操作）

---

## 1.24

**今日学习：**
- [x] 差分数组技巧

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 1094 | 拼车 | 中等 | ✅ |
| 1109 | 航班预订统计 | 中等 | ✅ |

**笔记：**
- 差分数组是前缀和的逆运算，适合处理**区间增减**问题
- 差分数组 `diff[i]` 表示 `nums[i] - nums[i-1]` 的差值
- 对区间 `[l, r]` 加 val：`diff[l] += val`，`diff[r+1] -= val`
- 通过前缀和还原原数组：`nums[i] = diff[0] + diff[1] + ... + diff[i]`
- 注意区间是闭区间 `[l, r]` 还是左闭右开 `[l, r)`，决定减的位置是 `r+1` 还是 `r`
- 差分数组必须按顺序累加才能得到正确结果，不能在遍历 trips 时直接判断（因为输入顺序不等于时间顺序）

---

## 1.23

**今日学习：**
- [x] 前缀和技巧
- [x] 二维前缀和
- [x] 前缀积
- [x] 哈希表 + 前缀和优化

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 303 | 区域和检索 - 数组不可变 | 简单 | ✅ |
| 304 | 二维区域和检索 - 矩阵不可变 | 中等 | ✅ |
| 238 | 除了自身以外数组的乘积 | 中等 | ✅ |
| 523 | 连续的子数组和 | 中等 | ✅ |
| 525 | 连续数组 | 中等 | ✅ |
| 724 | 寻找数组的中心下标 | 简单 | ✅ |
| 1314 | 矩阵区域和 | 中等 | ✅ |
| 1352 | 最后 K 个数的乘积 | 中等 | ✅ |

**笔记：**
- 前缀和数组 `preSum[i]` 存储 `nums[0..i-1]` 的和，方便 O(1) 查询区间和
- 二维前缀和：`preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i-1][j-1] - preSum[i-1][j-1]` 存储[0, 0, i-1, j-1]的和
- 区域和查询：`sumRegion = preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1]`，不明白就画图
- 哈希表记录前缀和首次出现位置，可用于找和为0或和为k的子数组
- 同余定理：`(preSum[i] - preSum[j]) % k == 0` 等价于 `preSum[i] % k == preSum[j] % k`
- 除自身以外的乘积：用左侧前缀积和右侧后缀积相乘，可优化到O(1)空间
- 使用 `max/min` 可以优雅地避免索引越界

---

## 1.22

**今日学习：**
- [x] 链表经典题目：合并、分隔链表
- [x] Lambda 表达式在算法中的应用
- [x] 优先队列（小顶堆）的使用
- [x] 链表双指针技巧：快慢指针
- [x] 链表成环检测与找环入口
- [x] 链表相交问题

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 19 | 删除链表的倒数第N个结点 | 中等 | ✅ |
| 21 | 合并两个有序链表 | 简单 | ✅ |
| 23 | 合并K个升序链表 | 困难 | ✅ |
| 82 | 删除排序链表中的重复元素 II | 中等 | ✅ |
| 83 | 删除排序链表中的重复元素 | 简单 | ✅ |
| 86 | 分隔链表 | 中等 | ✅ |
| 141 | 环形链表 | 简单 | ✅ |
| 142 | 环形链表 II | 中等 | ✅ |
| 160 | 相交链表 | 简单 | ✅ |
| 876 | 链表的中间结点 | 简单 | ✅ |

**笔记：**
- 合并链表使用虚拟头节点 + 双指针
- 合并K个链表用小顶堆优化，时间复杂度 O(nlogk)
- Lambda 自定义优先队列比较器：`auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };`
- 分隔链表时注意断开原链表连接，避免成环
- 不确定头节点会不会变？加个虚拟头节点准没错，刷题时可以默认先加上，简化边界处理
- 快慢指针找中点：快指针走两步，慢指针走一步，快指针到末尾时慢指针在中点
- 判断链表成环：快慢指针相遇即有环
- 找环入口：相遇后，一个指针回到起点，两指针同速前进再次相遇即为入口
- 相交链表：先计算长度差，让长链表先走差值步，再同步前进找交点
- 删除倒数第N个节点：快指针先走N+1步，然后同步前进，慢指针到达待删除节点的前一个
- 推荐使用 `nullptr` 而非 `NULL`，前者是空指针类型，后者通常是int

---

## 1.21

**今日学习：**
- [x] 手动实现动态数组 `MyArrayList` 
- [x] 单链表 & 双链表设计

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| 707 | 设计链表 | 中等 | ✅ |

**笔记：**
- 使用虚拟头节点可以统一链表操作
- 双链表需要同时维护 `prev` 和 `next` 指针

---

## 1.20

**今日学习：**
- [x] 各种STL中的数据结构常见API

---

<!-- 模板
## 1.XX

**今日学习：**
- [ ] 

**今日刷题：**
| 题号 | 题目 | 难度 | 状态 |
|------|------|------|------|
| | | | |

**笔记：**
- 
-->
