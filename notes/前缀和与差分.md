# 前缀和与差分

## 一维前缀和
- `preSum[i]` 存储 `nums[0..i-1]` 的和，O(1) 查询区间和
- 区间和：`sum(l, r) = preSum[r+1] - preSum[l]`
  ```cpp
  preSum.resize(nums.size() + 1);
  for(int i = 1; i < preSum.size(); i++)
      preSum[i] = preSum[i-1] + nums[i-1];
  // 查询 [left, right] 区间和
  return preSum[right+1] - preSum[left];
  ```

## 二维前缀和
- 构建：`preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i-1][j-1] - preSum[i-1][j-1]`
- 查询：`sumRegion = preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1]`
- 不明白就画 4×4 个格子图理解，不要线图

## 前缀积
- 除自身以外的乘积：左侧前缀积 × 右侧后缀积，可优化到 O(1) 空间
  ```cpp
  // O(1) 额外空间写法
  vector<int> ans(n, 1);
  int left = 1;
  for(int i = 0; i < n; i++) { ans[i] = left; left *= nums[i]; }
  int right = 1;
  for(int i = n-1; i >= 0; i--) { ans[i] *= right; right *= nums[i]; }
  ```

## 哈希表 + 前缀和
- 记录前缀和首次出现位置，可用于找和为 0 或和为 k 的子数组
- 同余定理：`(preSum[i] - preSum[j]) % k == 0` ⟺ `preSum[i] % k == preSum[j] % k`
  ```cpp
  // 连续子数组和（523）：前缀和取模 + 哈希表记录首次出现位置
  unordered_map<int, int> valToIndex;
  for(int i = 0; i <= n; i++) {
      int val = preSum[i] % k;
      if(!valToIndex.count(val)) valToIndex[val] = i;
  }
  // 连续数组（525）：将 0 视为 -1，转化为找和为 0 的最长子数组
  preSum[i] = preSum[i-1] + (nums[i-1] == 0 ? -1 : 1);
  ```

## 差分数组
- 差分是前缀和的逆运算，适合处理**区间增减**问题
- `diff[i]` 表示 `nums[i] - nums[i-1]`
- 对区间 `[l, r]` 加 val：`diff[l] += val`，`diff[r+1] -= val`
- 通过前缀和还原原数组
- 注意区间是 `[l, r]` 还是 `[l, r)`，决定减的位置是 `r+1` 还是 `r`
  ```cpp
  // 拼车（1094）：to 站已下车，所以是 diff[to] -= val 而非 diff[to+1]
  diff[from] += numPassengers;
  diff[to] -= numPassengers;
  ```
- 差分数组必须按顺序累加才能得到正确结果

## 相关题目
| 题号 | 题目 | 难度 |
|------|------|------|
| 238 | 除了自身以外数组的乘积 | 中等 |
| 303 | 区域和检索 - 数组不可变 | 简单 |
| 304 | 二维区域和检索 - 矩阵不可变 | 中等 |
| 523 | 连续的子数组和 | 中等 |
| 525 | 连续数组 | 中等 |
| 724 | 寻找数组的中心下标 | 简单 |
| 1094 | 拼车 | 中等 |
| 1109 | 航班预订统计 | 中等 |
| 1314 | 矩阵区域和 | 中等 |
| 1352 | 最后 K 个数的乘积 | 中等 |
