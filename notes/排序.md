# 排序

## 一、归并排序

### 核心思想

归并排序的 merge 过程天然地在比较"跨组元素对"，而且不重复不遗漏。利用这个性质，可以在排序的同时统计满足某种条件的元素对。

一句话总结了归并排序：先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并。

**本质：所有"统计满足条件的元素对"问题，如果暴力 O(n²) 超时，都可以考虑归并排序优化到 O(nlogn)。**

## 归并排序模板（912）

```cpp
vector<int> temp;

void mergeSort(vector<int>& nums, int lo, int hi) {
    if(lo >= hi) return;
    int mid = lo + (hi - lo) / 2;
    mergeSort(nums, lo, mid);
    mergeSort(nums, mid + 1, hi);
    merge(nums, lo, mid, hi);
}

void merge(vector<int>& nums, int lo, int mid, int hi) {
    for(int i = lo; i <= hi; i++) temp[i] = nums[i];
    int i = lo, j = mid + 1;
    for(int p = lo; p <= hi; p++) {
        if(i == mid + 1) {
            nums[p] = temp[j++];
        } else if(j == hi + 1) {
            nums[p] = temp[i++];
        } else if(temp[i] <= temp[j]) {
            nums[p] = temp[i++];
        } else {
            nums[p] = temp[j++];
        }
    }
}
```

## 为什么归并排序能统计元素对？

```
归并排序保证：
1. 同组内的比较 → 在更深层的递归中已经完成 ✓
2. 跨组的比较   → 在当前层 merge 中完成 ✓
3. 不重复不遗漏 → 每对元素恰好在某一层被比较一次 ✓
```

merge 时左半边 `[lo, mid]` 和右半边 `[mid+1, hi]` 都已排好序，可以利用有序性用双指针 O(n) 扫描，而不是暴力 O(n²)。

## 题目演进路线

```
912 归并排序（基础模板）
 │
 ├── LCR 170 逆序对（站在右边元素角度统计）
 │
 ├── 315 计算右侧小于当前元素的个数（站在左边元素角度统计 + 索引追踪）
 │
 ├── 493 翻转对（比较条件不同于排序条件 → 单独循环统计）
 │
 └── 327 区间和的个数（前缀和转化 + 归并统计 + 滑动窗口思想）
```

## 逆序对（LCR 170）

> 找所有 i < j 且 nums[i] > nums[j] 的对数

站在**右边元素**的角度统计：当取右边 `temp[j]` 时，说明它比左边剩余的 `[i, mid]` 都小，产生 `mid - i + 1` 个逆序对。

```cpp
// merge 中，当 temp[i] > temp[j] 时：
nums[p] = temp[j++];
count += mid - i + 1;  // 左边 [i, mid] 都比 temp[j] 大
```

**关键理解：** 右边元素被取走时就已经统计完了，所以右边用完（`j == hi + 1`）时不需要额外处理。

## 计算右侧小于当前元素的个数（315）

> 对每个 nums[i]，统计它右边比它小的元素个数

站在**左边元素**的角度统计：当取左边 `temp[i]` 时，右边已经被取走的 `[mid+1, j-1]` 都比它小。

**难点：** 排序会打乱原始索引，需要额外维护索引数组。

```cpp
vector<int> count;      // 结果数组
vector<int> index;      // 原始索引
vector<int> tempIndex;  // 辅助索引数组

// merge 中，当取左边元素时：
nums[p] = temp[i];
index[p] = tempIndex[i];
count[tempIndex[i]] += j - mid - 1;  // 右边已取走的都比它小
i++;
```

**两个统计时机：**
1. `temp[i] <= temp[j]`：取左边时，`count += j - mid - 1`
2. `j == hi + 1`（右边用完）：左边剩余元素也要统计，`count += j - mid - 1`（即 `hi - mid`）

### 315 vs LCR 170 的区别

| | LCR 170 逆序对 | 315 右侧更小 |
|---|---|---|
| 统计角度 | 右边元素 | 左边元素 |
| 统计时机 | 取右边时加 | 取左边时加 |
| 需要索引 | 不需要（只要总数） | 需要（每个元素单独计数） |
| 额外数组 | 无 | index + tempIndex |

## 翻转对（493）

> 找所有 i < j 且 nums[i] > 2 * nums[j] 的对数

**关键区别：** 比较条件（`> 2*`）和排序条件（`>`）不同，没办法在 merge 的比较中顺便统计。

**解决方案：** 在 merge 之前，单独写一个循环统计。此时左右两半都已排好序，可以用双指针 O(n) 扫描。

```cpp
void mergeSort(vector<int>& nums, int lo, int hi) {
    if(lo >= hi) return;
    int mid = lo + (hi - lo) / 2;
    mergeSort(nums, lo, mid);
    mergeSort(nums, mid + 1, hi);

    // ★ merge 之前先统计翻转对
    int j = mid + 1;
    for(int i = lo; i <= mid; i++) {
        while(j <= hi && (long long)nums[i] > (long long)2 * nums[j]) {
            j++;
        }
        count += j - (mid + 1);
    }

    merge(nums, lo, mid, hi);  // 标准 merge，不做额外统计
}
```

**为什么 j 不用重置？** 因为左半边是升序的，`nums[i]` 递增，满足条件的 j 范围只会右移（单调性），所以双指针总共 O(n)。

**注意：** `2 * nums[j]` 可能溢出 int，需要转 `long long`。

## 区间和的个数（327）

> 找所有子数组 [i, j] 使得 lower <= sum(i, j) <= upper

**转化思路：**
1. 子数组和 = `preSum[j+1] - preSum[i]`
2. 问题变成：找多少对 (i, j) 满足 `i < j` 且 `lower <= preSum[j] - preSum[i] <= upper`
3. 这就是在前缀和数组上找"满足条件的元素对"，和 315/493 一个套路

```cpp
// 对前缀和数组做归并排序
// merge 之前，统计跨组的满足条件的对数
// 维护左闭右开区间 [start, end)
int start = mid + 1, end = mid + 1;
for(int i = lo; i <= mid; i++) {
    while(start <= hi && nums[start] - nums[i] < lower) start++;
    while(end <= hi && nums[end] - nums[i] <= upper) end++;
    count += end - start;
}
```

**为什么 start 和 end 不用重置？** 同样是单调性：`nums[i]` 递增，`nums[?] - nums[i]` 递减，所以满足条件的区间 [start, end) 只会右移。

**注意：** 前缀和可能溢出 int，用 `long` 类型。

## 归并排序解题套路总结

遇到"统计满足条件的元素对"问题：

1. **判断能否用归并：** 条件是否涉及两个元素的大小关系？暴力是否 O(n²)？
2. **确定统计角度：**
   - 需要每个元素单独计数 → 站在左边角度（如 315）
   - 只需要总数 → 站在右边角度更简洁（如 LCR 170）
3. **确定统计位置：**
   - 比较条件和排序条件一致 → 在 merge 内部顺便统计（如 315、LCR 170）
   - 比较条件和排序条件不同 → 在 merge 之前单独统计（如 493、327）
4. **注意事项：**
   - 需要追踪原始索引时，维护 index 数组（如 315）
   - 可能溢出时用 `long long`（如 493 的 `2*nums[j]`、327 的前缀和）
   - 利用有序性 + 双指针/滑动窗口保证 O(n) 扫描

## 二、快速排序

### 核心思想

选一个 pivot，把数组分成「小于 pivot」「等于 pivot」「大于 pivot」三部分，然后递归排序左右两部分。

一句话总结：先将一个元素排好序（pivot 放到正确位置），再递归排左右。

### 归并 vs 快排

| | 归并排序 | 快速排序 |
|---|---|---|
| 思路 | 先递归排左右，再合并 | 先分区，再递归排左右 |
| 代码位置 | 逻辑在**后序位置**（merge） | 逻辑在**前序位置**（partition） |
| 稳定性 | 稳定 | 不稳定 |
| 空间 | O(n) 辅助数组 | O(logn) 递归栈 |
| 最坏时间 | O(nlogn) | O(n²)（随机化后期望 O(nlogn)） |

### 三路快排模板（912）

普通快排遇到大量重复元素会退化到 O(n²)，三路快排把等于 pivot 的元素聚集在中间，跳过不再递归。

```cpp
void quickSort(vector<int>& nums, int lo, int hi) {
    if(lo >= hi) return;
    // 随机选择 pivot，避免最坏情况
    int randIdx = lo + rand() % (hi - lo + 1);
    swap(nums[lo], nums[randIdx]);
    int pivot = nums[lo];

    // 三路划分
    // 不变量：
    //   nums[lo  .. lt-1] < pivot   （小于区）
    //   nums[lt  .. i-1 ] == pivot  （等于区）
    //   nums[gt+1.. hi  ] > pivot   （大于区）
    //   nums[i   .. gt  ]           （待处理区）
    int lt = lo, i = lo + 1, gt = hi;

    while(i <= gt) {
        if(nums[i] < pivot) {
            swap(nums[i++], nums[lt++]);  // 换到小于区，lt和i都右移
        } else if(nums[i] > pivot) {
            swap(nums[i], nums[gt--]);    // 换到大于区，gt左移，i不动（换来的还没检查）
        } else {
            i++;  // 等于pivot，直接跳过
        }
    }
    // 结束后：[lo, lt-1] < pivot, [lt, gt] == pivot, [gt+1, hi] > pivot
    quickSort(nums, lo, lt - 1);   // 只递归小于区
    quickSort(nums, gt + 1, hi);   // 只递归大于区，等于区跳过
}
```

**关键细节：**
- `nums[i] > pivot` 时 i 不动，因为从 gt 换过来的元素还没检查过
- `nums[i] < pivot` 时 i 可以动，因为从 lt 换过来的一定是 `== pivot`（之前扫过的）
- 随机化 pivot：`srand(time(0))` + `rand() % (hi - lo + 1)` 避免有序数组退化

### 快速选择（215）

> 找第 K 大的元素，不需要完全排序

快排每次 partition 后，pivot 就在最终位置上。只需要往 target 所在的那一侧递归，期望时间 O(N)。

```
时间分析：N + N/2 + N/4 + ... = O(2N) = O(N)
```

```cpp
int quickSelect(vector<int>& nums, int lo, int hi, int target) {
    if(lo == hi) return nums[lo];

    swap(nums[lo], nums[lo + rand() % (hi - lo + 1)]);
    int pivot = nums[lo];
    int lt = lo, i = lo + 1, gt = hi;

    while(i <= gt) {
        if(nums[i] < pivot) swap(nums[i++], nums[lt++]);
        else if(nums[i] > pivot) swap(nums[i], nums[gt--]);
        else i++;
    }

    // 只递归 target 所在的那一侧
    if(target < lt) return quickSelect(nums, lo, lt - 1, target);
    else if(target > gt) return quickSelect(nums, gt + 1, hi, target);
    else return nums[target];  // target 落在等于区，直接命中
}

// 第K大 = 升序排列后下标为 n-k
int findKthLargest(vector<int>& nums, int k) {
    return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);
}
```

**两种方法对比：**
| | 快速选择 | 小顶堆 |
|---|---|---|
| 时间 | 期望 O(N)，最坏 O(N²) | O(NlogK) |
| 空间 | O(1) 原地 | O(K) |
| 适用 | 数据全在内存中 | 数据流/在线场景 |

### 优先队列（堆）解 TopK（347）

当需要维护"前 K 个最大/最小"时，用大小为 K 的堆：
- 求前 K 大 → 小顶堆（堆顶最小，不够大的被淘汰）
- 求前 K 小 → 大顶堆（堆顶最大，不够小的被淘汰）

```cpp
// 小顶堆，维护 K 个最大元素
priority_queue<int, vector<int>, greater<int>> pq;
for(int x : nums) {
    pq.push(x);
    if(pq.size() > k) pq.pop();  // 弹出最小的
}
// pq.top() 就是第 K 大
```

## 相关题目
| 题号 | 题目 | 难度 | 关键点 |
|------|------|------|------|
| 912 | 排序数组 | 中等 | 归并排序/三路快排 |
| 215 | 数组中的第K个最大元素 | 中等 | 快速选择O(N)/小顶堆O(NlogK) |
| 347 | 前 K 个高频元素 | 中等 | 哈希表+小顶堆 |
| LCR 170 | 交易逆序对的总数 | 困难 | 右边角度统计 |
| 315 | 计算右侧小于当前元素的个数 | 困难 | 左边角度 + 索引追踪 |
| 493 | 翻转对 | 困难 | merge 前单独统计 |
| 327 | 区间和的个数 | 困难 | 前缀和转化 + 滑动窗口 |
