# 二分查找

## 基础框架
```cpp
int left = 0, right = nums.size() - 1;
while(left <= right) { // 左闭右闭区间 [left, right]
    int mid = left + (right - left) / 2;
    if(nums[mid] == target) return mid;
    else if(nums[mid] < target) left = mid + 1;
    else if(nums[mid] > target) right = mid - 1;
}
return -1;
```

## 寻找左侧边界（找满足条件的最小值）
- 当 `f(mid) <= target` 时，`right = mid - 1`（收缩右边界）
- 当 `f(mid) > target` 时，`left = mid + 1`
- 最终返回 `left`
- 返回值的三种等价解读：
  1. nums 中大于等于 target 的最小元素索引
  2. target 应该插入在 nums 中的索引位置
  3. nums 中小于 target 的元素个数

## STL `lower_bound` vs 手写
- `lower_bound`：代码简洁，STL 可靠，需记住语义（`>=`）
  ```cpp
  return lower_bound(preSum.begin(), preSum.end(), target) - preSum.begin();
  ```
- 手写：逻辑清晰，完全可控，容易写错边界
- 比赛建议：用自己最有把握的方式

## 转化问题：最值问题 → 二分搜索
- **本质**：在单调函数上寻找边界，将"求最值"转化为"判定"问题
- **关键**：找到单调性并正确定义 `f(x)`

### 爱吃香蕉的珂珂
- `f(x)` = 以速度 x 吃完所有香蕉需要的小时数，单调递减
- 目标：找最小的 x 使得 `f(x) <= h`
- 搜索空间：`[1, max(piles)]`
- 向上取整：`(piles[i] + x - 1) / x`

### 在 D 天内送达包裹的能力
- `f(x)` = 运载能力为 x 时需要的天数，单调递减
- 搜索空间：`[max(weights), sum(weights)]`

### 分割数组的最大值
- 与"送达包裹"完全一样的思路
- `f(x)` = 子数组和最大值为 x 时需要的子数组个数
- 核心：将"最小化最大值"转化为二分搜索

## 常见错误
- ❌ `while (left <= right)` 配合 `right = mid` → 死循环
- ✅ `while (left < right)` 配合 `right = mid` → 查找第一个位置

## 相关题目
| 题号 | 题目 | 难度 |
|------|------|------|
| 34 | 在排序数组中查找元素的第一个和最后一个位置 | 中等 |
| 35 | 搜索插入位置 | 简单 |
| 69 | x 的平方根 | 简单 |
| 278 | 第一个错误的版本 | 简单 |
| 367 | 有效的完全平方数 | 简单 |
| 410 | 分割数组的最大值 | 困难 |
| 566 | 重塑矩阵 | 简单 |
| 704 | 二分查找 | 简单 |
| 875 | 爱吃香蕉的珂珂 | 中等 |
| 1011 | 在 D 天内送达包裹的能力 | 中等 |
| LCR 172 | 统计目标成绩的出现次数 | 简单 |
