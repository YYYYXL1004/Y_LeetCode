# 图

## 核心概念

图的表示：邻接表 `vector<vector<int>>`（稀疏图常用）、邻接矩阵（稠密图）。

图的遍历本质是多叉树遍历 + `visited` 防止走回头路（有环时）。

```cpp
// DFS 遍历框架
vector<bool> visited;
void traverse(graph, int s) {
    if(visited[s]) return;
    visited[s] = true;
    // 前序位置：处理节点 s
    for(int next : graph[s]) {
        traverse(graph, next);
    }
    // 后序位置
}
```

## 一、所有可能的路径（797）

给定有向无环图（DAG），找出从节点 0 到节点 n-1 的所有路径。

DAG 无环，不需要 `visited`。用回溯收集路径。

```cpp
vector<vector<int>> res;
vector<int> path;

void traverse(vector<vector<int>>& graph, int s) {
    path.push_back(s);
    int n = graph.size();
    if(s == n - 1) {
        res.push_back(path);
        path.pop_back();
        return;
    }
    for(int v : graph[s]) {
        traverse(graph, v);
    }
    path.pop_back(); // 回溯
}

vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
    traverse(graph, 0);
    return res;
}
```

也可以用 BFS（队列中存整条路径），但空间开销大，本题更推荐 DFS。

## 二、克隆图（133）

深拷贝一个无向连通图。

DFS 遍历 + 哈希表记录「原节点 → 克隆节点」的映射，递归过程中构建克隆图的邻居关系。

```cpp
unordered_set<Node*> visited;
unordered_map<Node*, Node*> originToClone;

void traverse(Node* node) {
    if(!node || visited.count(node)) return;
    visited.insert(node);
    // 克隆当前节点
    if(!originToClone.count(node))
        originToClone[node] = new Node(node->val);
    Node* cloneNode = originToClone[node];

    for(Node* next : node->neighbors) {
        traverse(next);
        // 递归之后，邻居节点一定已在 map 中
        cloneNode->neighbors.push_back(originToClone[next]);
    }
}

Node* cloneGraph(Node* node) {
    traverse(node);
    return originToClone[node];
}
```

关键：在前序位置创建克隆节点，在递归返回后连接邻居，保证邻居已被克隆。

## 相关题目

| 题号 | 题目 | 难度 | 备注 |
|------|------|------|------|
| 797 | 所有可能的路径 | 中等 | DAG 回溯收集路径，无需 visited |
| 133 | 克隆图 | 中等 | DFS + 哈希表映射原节点到克隆节点 |
