# 滑动窗口

## 框架
```cpp
int left = 0, right = 0;
while (right < s.size()) {
    char c = s[right];
    right++;  // 扩大窗口
    // 更新窗口内数据...

    while (window needs shrink) {
        char d = s[left];
        left++;  // 缩小窗口
        // 更新窗口内数据...
    }
}
```

## 经典应用

### 最小覆盖子串
- 用 `need` 记录目标字符频率，`window` 记录窗口内字符频率
- `valid` 记录窗口中满足 `need` 条件的字符种类数
- 窗口收缩条件：`valid == need.size()`（满足覆盖要求时）
  ```cpp
  while(valid == need.size()) {
      if(right - left < len) { start = left; len = right - left; }
      char d = s[left]; left++;
      if(need.count(d)) {
          if(window[d] == need[d]) valid--;
          window[d]--;
      }
  }
  ```

### 字符串的排列 / 找所有字母异位词
- 固定窗口大小为目标串长度
- 当 `right - left >= n` 时判断是否满足条件并收缩窗口
  ```cpp
  while(right - left >= n) {
      if(valid == need.size()) return true; // 排列：返回true / 异位词：记录left
      char d = s[left]; left++;
      if(need.count(d)) {
          if(window[d] == need[d]) valid--;
          window[d]--;
      }
  }
  ```

### 无重复字符的最长子串
- 窗口收缩条件：`window[c] > 1`（出现重复字符）
- 收缩后保证窗口内无重复，然后更新最大长度
  ```cpp
  while(window[c] > 1) { window[s[left]]--; left++; }
  res = max(res, right - left);
  ```

### 将 x 减到 0 的最小操作数
- **转化思维**：从两端删除和为 x ⟺ 保留中间和为 `sum - x` 的最长子数组
- 窗口收缩条件：`windowSum > target`
- 答案为 `n - maxLen`（若不存在返回 -1）

## 滑动窗口 vs 双指针
- 滑动窗口适合"连续子数组/子串"问题
- 双指针更通用，可处理排序数组、链表等

## 相关题目
| 题号 | 题目 | 难度 |
|------|------|------|
| 3 | 无重复字符的最长子串 | 中等 |
| 76 | 最小覆盖子串 | 困难 |
| 438 | 找到字符串中所有字母异位词 | 中等 |
| 567 | 字符串的排列 | 中等 |
| 1658 | 将 x 减到 0 的最小操作数 | 中等 |
