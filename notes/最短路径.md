# 最短路径（Dijkstra）

## 核心框架

Dijkstra 算法本质是 **贪心 + BFS**：用优先队列（最小堆）每次取出「距离起点最近」的节点，用它去松弛（relax）相邻节点。第一次从堆中弹出某个节点时，该距离一定是最短距离。

时间复杂度：O(E log V)，空间复杂度：O(V + E)

```cpp
struct State{
    int node;
    int distFromStart;
    State(int node, int distFromStart) : node(node), distFromStart(distFromStart) {}

    bool operator < (const State& other) const {
        return distFromStart > other.distFromStart; // 最小堆
    }
};

// graph[from] -> (to, weight)
vector<int> dijkstra(vector<vector<pair<int, int>>>& graph, int src) {
    int n = graph.size();
    vector<int> distTo(n, INT_MAX);

    priority_queue<State> pq;
    pq.emplace(src, 0);
    distTo[src] = 0;

    while(!pq.empty()) {
        State cur = pq.top();
        pq.pop();
        int curNode = cur.node;
        int curDistFromStart = cur.distFromStart;

        if(distTo[curNode] < curDistFromStart) continue; // 剪枝

        for(auto& neighbor : graph[curNode]) {
            int nextNode = neighbor.first;
            int nextDistFromStart = neighbor.second + curDistFromStart;

            if(distTo[nextNode] <= nextDistFromStart) continue; // 剪枝
            pq.emplace(nextNode, nextDistFromStart);
            distTo[nextNode] = nextDistFromStart; // 更新
        }
    }
    return distTo;
}
```

关键点：
- 重载 `operator<` 时用 `>`，让默认最大堆的 `priority_queue` 变成最小堆
- `if(distTo[curNode] < curDistFromStart) continue;` 弹出时剪枝，跳过过时记录
- `distTo` 在入队时更新，能有效减少重复入队。标准 Dijkstra 中入队/弹出更新等价（排序维度 = 剪枝维度 = 距离）

## 一、网络延迟时间（743）

标准 Dijkstra 模板题。n 个节点、有向加权图，求从节点 k 出发到所有节点的最短路径中的最大值。

```cpp
struct State{
    int node;
    int distFromStart;
    State(int node, int distFromStart) : node(node), distFromStart(distFromStart) {}

    bool operator < (const State& other) const {
        return distFromStart > other.distFromStart;
    }
};

// graph[from] -> (to, weight)
vector<int> dijkstra(vector<vector<pair<int, int>>>& graph, int src) {
    int n = graph.size();
    vector<int> distTo(n + 1, INT_MAX);

    priority_queue<State> pq;
    pq.emplace(src, 0);
    distTo[src] = 0;

    while(!pq.empty()) {
        State cur = pq.top();
        pq.pop();
        int curNode = cur.node;
        int curDistFormStart = cur.distFromStart;

        if(distTo[curNode] < curDistFormStart) continue;

        for(auto& neighbor : graph[curNode]) {
            int nextNode = neighbor.first;
            int nextDistFromStart = neighbor.second + curDistFormStart;

            if(distTo[nextNode] <= nextDistFromStart) continue;
            pq.emplace(nextNode, nextDistFromStart);
            distTo[nextNode] = nextDistFromStart;
        }
    }
    return distTo;
}

int networkDelayTime(vector<vector<int>>& times, int n, int k) {
    vector<vector<pair<int, int>>> graph(n + 1);
    for(auto& edge : times) {
        int from = edge[0];
        int to = edge[1];
        int w = edge[2];
        graph[from].push_back({to, w});
    }

    vector<int> distTo = dijkstra(graph, k);
    int res = 0;
    for(int i = 1; i <= n; i++) {
        if(distTo[i] == INT_MAX) return -1;
        res = max(res, distTo[i]);
    }
    return res;
}
```

## 二、概率最大的路径（1514）

无向加权图，边权是概率（0~1），求从 start 到 end 的最大概率路径。

和标准 Dijkstra 的区别：
- 求最大概率而非最小距离 → **最大堆**（`operator<` 用 `<` 而非 `>`）
- 初始值：`probTo` 初始化为 `0.0`，起点为 `1.0`
- 松弛条件：乘法 `curProb * edgeProb`，而非加法
- 剪枝方向反转：`probTo[curNode] > curProbFromStart` 跳过

```cpp
struct State{
    int node;
    double probFromStart;
    State(int node, double probFromStart) : node(node), probFromStart(probFromStart) {}
    // 让概率大的先出来
    bool operator <(const State& other) const {
        return probFromStart < other.probFromStart;
    }
};

// graph[from] -> {to, prob}
double dijkstra(vector<vector<pair<int, double>>>& graph, int src, int dst) {
    int n = graph.size();
    vector<double> probTo(n, 0.0);

    priority_queue<State> pq;
    pq.emplace(src, 1.0);
    probTo[src] = 1.0;

    while(!pq.empty()) {
        State cur = pq.top();
        pq.pop();
        int curNode = cur.node;
        double curProbFromStart = cur.probFromStart;

        if(probTo[curNode] > curProbFromStart) continue;
        if(curNode == dst) return probTo[dst];
        for(auto& neighbor : graph[curNode]) {
            int nextNode = neighbor.first;
            double nextProbFromStart = neighbor.second * curProbFromStart;

            if(probTo[nextNode] >= nextProbFromStart) continue;
            pq.emplace(nextNode, nextProbFromStart);
            probTo[nextNode] = nextProbFromStart;
        }
    }
    return 0.0;
}

double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {
    vector<vector<pair<int, double>>> graph(n);
    for(int i = 0; i < edges.size(); i++) {
        int a = edges[i][0];
        int b = edges[i][1];
        double p = succProb[i];
        graph[a].push_back({b, p});
        graph[b].push_back({a, p}); // 无向图
    }
    return dijkstra(graph, start_node, end_node);
}
```

## 三、最小体力消耗路径（1631）

网格图，从左上角走到右下角，路径的「体力消耗」定义为路径上相邻格子高度差绝对值的最大值。求最小体力消耗。

和标准 Dijkstra 的区别：
- 节点是网格坐标 `(row, col)`，`distTo` 变成二维数组
- 松弛条件：`max(curDist, abs(高度差))`，而非 `curDist + weight`（取路径上的最大边权）
- 到达右下角时可以提前返回

```cpp
struct State{
    int row;
    int col;
    int distFromStart;
    State(int row, int col, int distFromStart) : row(row), col(col), distFromStart(distFromStart) {}

    bool operator < (const State& other) const {
        return distFromStart > other.distFromStart;
    }
};

int dijkstra(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    vector<vector<int>> distTo(m, vector<int>(n, INT_MAX));

    priority_queue<State> pq;
    pq.emplace(0, 0, 0);
    distTo[0][0] = 0;

    while(!pq.empty()) {
        State cur = pq.top();
        pq.pop();
        int curRow = cur.row;
        int curCol = cur.col;
        int curDistFormStart = cur.distFromStart;

        if(distTo[curRow][curCol] < curDistFormStart) continue;

        if(curRow == m - 1 && curCol == n - 1) {
            return distTo[curRow][curCol];
        }

        for(auto& neighbor : adj(matrix, curRow, curCol)) {
            int nextRow = neighbor[0];
            int nextCol = neighbor[1];
            // 取路径上的最大高度差，而非累加
            int nextDistFromStart = max(curDistFormStart, abs(matrix[nextRow][nextCol] - matrix[curRow][curCol]));

            if(distTo[nextRow][nextCol] <= nextDistFromStart) continue;

            pq.emplace(nextRow, nextCol, nextDistFromStart);
            distTo[nextRow][nextCol] = nextDistFromStart;
        }
    }
    return -1;
}

// 返回坐标 (x, y) 的上下左右相邻坐标
vector<vector<int>> adj(vector<vector<int>>& matrix, int x, int y) {
    vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    int m = matrix.size(), n = matrix[0].size();
    vector<vector<int>> neighbors;
    for(auto& dir : dirs) {
        int nx = x + dir[0];
        int ny = y + dir[1];
        if(nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
        neighbors.push_back({nx, ny});
    }
    return neighbors;
}
```

## 四、使网格图至少有一条有效路径的最小代价（1368）

网格图，每个格子有一个箭头方向（1右 2左 3下 4上）。从 `(0,0)` 走到 `(m-1,n-1)`，可以走任意方向，但如果走的方向和箭头不一致就要花 1 的代价改箭头。求最少改多少次。

转化思路：把「改箭头的最小次数」转化为「边权为 0/1 的图上的最短路」：
- 方向一致 → 边权 0（免费走）
- 方向不一致 → 边权 1（改一次）

`adj` 函数返回邻居时额外带上 `dirID`，dijkstra 里判断当前格子箭头方向和实际走的方向是否一致。

```cpp
struct State{
    int x, y;
    int costFromStart;
    State(int x, int y, int costFromStart) : x(x), y(y), costFromStart(costFromStart) {}

    bool operator < (const State& other) const {
        return costFromStart > other.costFromStart;
    }
};

// 四个方向：1-右 2-左 3-下 4-上（与题目定义一致）
int dirs[5][2] = {{0,0}, {0,1}, {0,-1}, {1,0}, {-1,0}};

// 返回坐标 (x, y) 的上下左右相邻坐标及对应的 dirID
vector<vector<int>> adj(vector<vector<int>>& grid, int x, int y) {
    int m = grid.size(), n = grid[0].size();
    vector<vector<int>> neighbors;
    for(int dirID = 1; dirID <= 4; dirID++) {
        int nx = x + dirs[dirID][0];
        int ny = y + dirs[dirID][1];
        if(nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
        neighbors.push_back({nx, ny, dirID});
    }
    return neighbors;
}

int dijkstra(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    vector<vector<int>> costTo(m, vector<int>(n, INT_MAX));
    priority_queue<State> pq;
    pq.emplace(0, 0, 0);
    costTo[0][0] = 0;

    while(!pq.empty()) {
        State cur = pq.top();
        pq.pop();
        int curX = cur.x;
        int curY = cur.y;
        int curCostFromStart = cur.costFromStart;

        if(curX == m - 1 && curY == n - 1) return curCostFromStart;

        if(costTo[curX][curY] < curCostFromStart) continue;

        for(auto& neighbor : adj(grid, curX, curY)) {
            int nx = neighbor[0];
            int ny = neighbor[1];
            int dirID = neighbor[2];
            // 箭头方向和走的方向一致则代价 0，否则代价 1
            int cost = (grid[curX][curY] == dirID) ? 0 : 1;
            int nextCostFromStart = curCostFromStart + cost;

            if(costTo[nx][ny] <= nextCostFromStart) continue;

            pq.emplace(nx, ny, nextCostFromStart);
            costTo[nx][ny] = nextCostFromStart;
        }
    }
    return -1;
}
```

因为边权只有 0 和 1，这题也可以用 0-1 BFS（双端队列 BFS）优化。

## 五、K 站中转内最便宜的航班（787）

有向加权图，求从 src 到 dst 最多经过 k 次中转的最便宜价格。

这题是 Dijkstra 最特殊的变体，核心区别：**排序维度（代价）和剪枝维度（边数）不一致**。

为什么不能用 `distTo` 剪枝？
- 距离更短的路径可能中转次数更多，后续无法在 k 次内到达终点
- 反之，距离稍长但中转次数少的路径可能才是有效答案
- 所以改用 `edgeTo`（最少边数）来剪枝

为什么 `edgeTo` 必须在弹出时更新，不能在入队时更新？
- 入队时提前更新可能误杀有效路径：
  - 路径A: 2条边、代价100 先入队，设 `edgeTo[X]=2`
  - 路径B: 3条边、代价50 入队时被 `edgeTo[X]<=3` 拦掉
  - 但路径B代价更低，如果 k 够大它才是答案
- 弹出时更新就没这个问题：代价50的B会先弹出，安全处理

对比标准 Dijkstra：排序维度和剪枝维度一致时，入队/弹出更新都行；不一致时（787），弹出时更新更安全。

```cpp
struct State{
    int node;
    int distFromStart;
    int edgeFromStart;
    State(int node, int distFromStart, int edgeFromStart) : node(node), distFromStart(distFromStart), edgeFromStart(edgeFromStart) {}

    bool operator< (const State& other) const {
        return distFromStart > other.distFromStart;
    }
};

int dijkstra(vector<vector<pair<int, int>>>& graph, int src, int dst, int k) {
    int n = graph.size();
    vector<int> edgeTo(n, INT_MAX); // edgeTo[i]: 到达节点 i 用过的最少边数

    priority_queue<State> pq;
    pq.emplace(src, 0, 0);
    edgeTo[src] = 0;
    while(!pq.empty()) {
        State cur = pq.top();
        pq.pop();
        int curNode = cur.node;
        int curDistFromStart = cur.distFromStart;
        int curEdgeFromStart = cur.edgeFromStart;

        // 最小堆保证第一次弹出终点时代价最优
        if(curNode == dst) return curDistFromStart;
        // 中转次数超了，跳过这条路径（不能 return -1，其他路径可能还行）
        if(curEdgeFromStart > k) continue;
        // 之前用更少的边数到过这个节点，跳过
        if(edgeTo[curNode] < curEdgeFromStart) continue;
        // 弹出时才更新 edgeTo
        edgeTo[curNode] = curEdgeFromStart;

        for(auto& neighbor : graph[curNode]) {
            int nextNode = neighbor.first;
            int nextDistFromStart = neighbor.second + curDistFromStart;
            int nextEdgeFromStart = curEdgeFromStart + 1;
            if(edgeTo[nextNode] <= nextEdgeFromStart) continue; // 边数剪枝
            pq.emplace(nextNode, nextDistFromStart, nextEdgeFromStart);
        }
    }
    return -1;
}

int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
    vector<vector<pair<int, int>>> graph(n);
    for(auto& edge : flights) {
        int from = edge[0];
        int to = edge[1];
        int price = edge[2];
        graph[from].push_back({to, price});
    }
    return dijkstra(graph, src, dst, k);
}
```

## 总结：Dijkstra 变体对比

| 题目 | 堆类型 | 松弛方式 | 剪枝数组 | 特殊点 |
|------|--------|----------|----------|--------|
| 743 网络延迟时间 | 最小堆 | `curDist + weight` | `distTo` | 标准模板 |
| 1514 概率最大路径 | 最大堆 | `curProb * edgeProb` | `probTo` | 乘法松弛，方向反转 |
| 1631 最小体力消耗 | 最小堆 | `max(curDist, 高度差)` | `distTo` | 网格图，max 松弛 |
| 1368 有效路径最小代价 | 最小堆 | `curCost + (0或1)` | `costTo` | 网格图，边权 0/1 |
| 787 K站中转最便宜 | 最小堆 | `curDist + weight` | `edgeTo`(边数) | 排序≠剪枝，弹出时更新 |

## 相关题目

| 题号 | 题目 | 难度 | 关键点 |
|------|------|------|--------|
| 743 | 网络延迟时间 | 中等 | 标准 Dijkstra 模板题 |
| 787 | K 站中转内最便宜的航班 | 中等 | 带中转限制，edgeTo 剪枝 |
| 1368 | 使网格图至少有一条有效路径的最小代价 | 困难 | 网格图 + 边权 0/1 |
| 1514 | 概率最大的路径 | 中等 | 最大堆 + 概率松弛 |
| 1631 | 最小体力消耗路径 | 中等 | 网格图 + max 松弛 |
