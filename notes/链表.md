# 链表

## 基本技巧
- 不确定头节点会不会变？加个虚拟头节点准没错
- 推荐使用 `nullptr` 而非 `NULL`
- 链表去重与数组去重对应：`slow->next = fast` 对应 `nums[slow] = nums[fast]`
- 链表去重最后需要 `slow->next = nullptr` 断开尾部
- 分隔链表时注意断开原链表连接，避免成环

## 合并链表
- 合并两个有序链表：虚拟头节点 + 双指针
- 合并 K 个升序链表：小顶堆优化，O(nlogk)
- Lambda 自定义比较器：`auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };`

## 反转链表

### 反转整个链表
- **迭代版**：
  ```cpp
  ListNode *pre = nullptr, *cur = head, *nxt = head->next;
  while(cur != nullptr) {
      cur->next = pre;
      pre = cur;
      cur = nxt;
      if(nxt != nullptr) nxt = nxt->next;
  }
  return pre;
  ```
- **递归版**：
  ```cpp
  if(head == nullptr || head->next == nullptr) return head;
  ListNode* last = reverseList(head->next);
  head->next->next = head;
  head->next = nullptr;
  return last;
  ```

### 反转前 N 个节点（模板）
- **迭代版**（推荐）：
  ```cpp
  ListNode* reverseN(ListNode* head, int n) {
      if(!head || !head->next) return head;
      ListNode *pre = nullptr, *cur = head, *nxt = head->next;
      while(n--) {
          cur->next = pre;
          pre = cur;
          cur = nxt;
          if(nxt != nullptr) nxt = nxt->next;
      }
      head->next = cur;  // 关键：原head连接到第n+1个节点
      return pre;
  }
  ```
- **递归版**：
  ```cpp
  ListNode* successor = nullptr;
  ListNode* reverseN(ListNode* head, int n) {
      if(n == 1) { successor = head->next; return head; }
      ListNode* last = reverseN(head->next, n - 1);
      head->next->next = head;
      head->next = successor;
      return last;
  }
  ```

### 区间反转
- 递归思路：当 `left == 1` 时，相当于反转前 `right` 个节点
- 否则递归：`head->next = reverseBetween(head->next, left - 1, right - 1)`

### K 个一组翻转
```cpp
ListNode* reverseKGroup(ListNode* head, int k) {
    if(k == 1 || !head || !head->next) return head;
    ListNode *a = head, *b = head;
    for(int i = 0; i < k; i++) {
        if(b == nullptr) return head;  // 不足k个直接返回
        b = b->next;
    }
    ListNode* newHead = reverseN(a, k);
    a->next = reverseKGroup(b, k);
    return newHead;
}
```

## 回文链表判断
- **方法一**：转化为数组 + 双指针，O(n) 时间 O(n) 空间
- **方法二**（推荐）：快慢指针找中点 + 反转后半部分 + 比较，O(n) 时间 O(1) 空间
- **方法三**：递归后序遍历，O(n) 时间 O(n) 空间
- 快慢指针找中点：`while(fast->next && fast->next->next)`
- 奇数链表：slow 是中点；偶数链表：slow 是左中点

## 递归三要素
1. 递归函数的定义是什么？
2. 递归终止条件是什么？
3. 这一层递归应该做什么？

## 常见错误
- ❌ 忘记处理 `nxt` 为空的情况
- ❌ 反转前 N 个节点后忘记连接后续节点 `head->next = cur`
- ✅ 想不清楚就画图，用 `1->2->3->4` 反转前 3 个试试

## 迭代 vs 递归
- 迭代：空间 O(1)，逻辑直观，适合面试手写
- 递归：代码简洁，但有栈空间开销 O(n)
- 建议：掌握迭代版作为主力，递归版理解思路

## 相关题目
| 题号 | 题目 | 难度 |
|------|------|------|
| 19 | 删除链表的倒数第 N 个结点 | 中等 |
| 21 | 合并两个有序链表 | 简单 |
| 23 | 合并 K 个升序链表 | 困难 |
| 25 | K 个一组翻转链表 | 困难 |
| 82 | 删除排序链表中的重复元素 II | 中等 |
| 83 | 删除排序链表中的重复元素 | 简单 |
| 86 | 分隔链表 | 中等 |
| 92 | 反转链表 II | 中等 |
| 206 | 反转链表 | 简单 |
| 234 | 回文链表 | 简单 |
| 707 | 设计链表 | 中等 |
