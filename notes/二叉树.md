# 二叉树

## 遍历框架
```cpp
void traverse(TreeNode* root) {
    if(root == nullptr) return;
    // 前序位置
    traverse(root->left);
    // 中序位置
    traverse(root->right);
    // 后序位置
}
```

## 三种思维模式
1. **遍历思维**：用 traverse 遍历所有节点，维护外部变量
2. **分治思维**：定义递归函数的返回值，用子问题答案推导原问题
3. **层序遍历**：BFS 适合按层处理或求最短路径

## 通用思考过程
1. 能否通过遍历一遍得到答案？
2. 能否定义递归函数，用子问题答案推导原问题？
3. 如果需要子树信息，优先考虑后序遍历

## 前序 vs 后序位置
- **前序位置**：只能获取父节点传递的数据
- **后序位置**：可以获取子树的返回值（子树信息）
- **选择原则**：需要子树信息时用后序，否则前序更直观
- **前序/后序都可以翻转二叉树**，中序不行（会导致某些节点被翻转两次）

## 动态规划、回溯、DFS 的关系
- **动态规划**：关注整棵「子树」
- **回溯算法**：关注节点间的「树枝」
- **DFS 算法**：关注单个「节点」

## DFS vs BFS 选择
- **DFS**：适合需要遍历所有节点、或需要子树信息的问题
- **BFS**：适合求最短路径、最小深度等"最近"问题
- **BFS 本质**：层层扩展，第一次到达目标就是最短路径

## 层序遍历（BFS）
```cpp
void traverse(TreeNode* root) {
    if(root == nullptr) return;
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()) {
        int sz = q.size();
        vector<int> level;
        for(int i = 0; i < sz; i++) {
            TreeNode* cur = q.front(); q.pop();
            level.push_back(cur->val);
            if(cur->left) q.push(cur->left);
            if(cur->right) q.push(cur->right);
        }
        res.push_back(level);
    }
}
```
- 带权重/深度信息：用 State 类封装节点和额外信息

## 最大深度
- **分治思维**（推荐）：
  ```cpp
  int maxDepth(TreeNode* root) {
      if(root == nullptr) return 0;
      return max(maxDepth(root->left), maxDepth(root->right)) + 1;
  }
  ```

## 最小深度
- **BFS**（推荐）：第一个遇到的叶子节点即为最小深度
- 注意：叶子节点必须是左右子节点都为空的节点

## 二叉树的直径
- 直径 = 某节点的左子树最大深度 + 右子树最大深度
- 后序位置：在计算最大深度的同时顺便计算直径
- 注意：直径不一定经过根节点，需要在每个节点处更新

## 完全二叉树的节点个数
- 利用完全二叉树性质 O(log²N)
- 关键性质：两棵子树至少有一棵是满二叉树
- 满二叉树节点数 = 2^h - 1
  ```cpp
  int countNodes(TreeNode* root) {
      if(root == nullptr) return 0;
      TreeNode *l = root, *r = root;
      int hl = 0, hr = 0;
      while(l) { l = l->left; hl++; }
      while(r) { r = r->right; hr++; }
      if(hl == hr) return pow(2, hl) - 1;
      return 1 + countNodes(root->left) + countNodes(root->right);
  }
  ```
- 每次递归只进入一棵子树，递归深度 O(logN)，每层算高度 O(logN)

## 二叉树的所有路径（回溯）
- 维护当前路径 `path`，到达叶子节点时记录结果
- 前序位置加入节点，后序位置弹出节点（回溯）

## 翻转二叉树
- **分治思维**（推荐）：
  ```cpp
  TreeNode* invertTree(TreeNode* root) {
      if(root == nullptr) return nullptr;
      TreeNode* l = invertTree(root->left);
      TreeNode* r = invertTree(root->right);
      root->left = r;
      root->right = l;
      return root;
  }
  ```

## 填充 next 指针（三叉树思维）
- 核心洞察：需要连接跨父节点的堂兄弟
- 解决方案：将问题转化为"连接两个相邻节点"
  ```cpp
  void traverse(Node* node1, Node* node2) {
      if(node1 == nullptr || node2 == nullptr) return;
      node1->next = node2;
      traverse(node1->left, node1->right);
      traverse(node2->left, node2->right);
      traverse(node1->right, node2->left);  // 关键！
  }
  ```

## 二叉树展开为链表（后序位置的妙用）
- 先递归拉平左右子树，再在后序位置拼接
- 左子树置空 → 右子树接上原左子树 → 找到末尾接上原右子树

## 构造二叉树

### 从前序与中序构造（105）
- 前序第一个元素是根节点，在中序中找到根的位置，划分左右子树
  ```cpp
  unordered_map<int, int> mp; // inorder 的 valToIndex
  TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                  vector<int>& inorder, int inStart, int inEnd) {
      if(preStart > preEnd) return nullptr;
      int rootVal = preorder[preStart];
      int index = mp[rootVal];
      int leftSize = index - inStart;
      TreeNode* root = new TreeNode(rootVal);
      root->left = build(preorder, preStart+1, preStart+leftSize, inorder, inStart, index-1);
      root->right = build(preorder, preStart+leftSize+1, preEnd, inorder, index+1, inEnd);
      return root;
  }
  ```

### 从中序与后序构造（106）
- 后序最后一个元素是根节点，其余逻辑同上
  ```cpp
  int rootVal = postorder[postEnd];
  int index = mp[rootVal];
  int leftSize = index - inStart;
  root->left = build(inorder, inStart, index-1, postorder, postStart, postStart+leftSize-1);
  root->right = build(inorder, index+1, inEnd, postorder, postStart+leftSize, postEnd-1);
  ```

### 从前序与后序构造（889）
- 前序第二个元素是左子树根，在后序中找到它来划分左右子树
- 注意 base case：`preStart == preEnd` 时直接返回（保证 `preStart+1` 不越界）
  ```cpp
  int leftRootVal = preorder[preStart + 1];
  int leftRootIndexInPost = postmp[leftRootVal];
  int leftSize = leftRootIndexInPost - postStart + 1;
  ```
- 前序+后序构造的结果不唯一（当某节点只有一个子节点时）

### 最大二叉树（654）
- 找区间最大值作为根，左右子区间递归构造
  ```cpp
  TreeNode* build(vector<int>& nums, int lo, int hi) {
      if(lo > hi) return nullptr;
      int index = lo, maxVal = -1;
      for(int i = lo; i <= hi; i++)
          if(nums[i] > maxVal) { index = i; maxVal = nums[i]; }
      TreeNode* root = new TreeNode(maxVal);
      root->left = build(nums, lo, index-1);
      root->right = build(nums, index+1, hi);
      return root;
  }
  ```

## 序列化与反序列化（297）

将二叉树转为字符串，再从字符串还原。三种遍历方式都可以实现。

### 方法一：前序遍历（推荐）
- 序列化：前序遍历，空节点用 `#` 标记，逗号分隔
- 反序列化：用队列按顺序取元素，递归构造
  ```cpp
  // 序列化
  void serialize(TreeNode* root, string& res) {
      if(root == nullptr) { res += "#,"; return; }
      res += to_string(root->val) + ",";
      serialize(root->left, res);
      serialize(root->right, res);
  }
  // 反序列化
  TreeNode* deserialize(queue<string>& nodes) {
      string val = nodes.front(); nodes.pop();
      if(val == "#") return nullptr;
      TreeNode* root = new TreeNode(stoi(val));
      root->left = deserialize(nodes);
      root->right = deserialize(nodes);
      return root;
  }
  ```

### 方法二：后序遍历
- 序列化：后序遍历，空节点用 `#` 标记
- 反序列化：从末尾取元素（`deque::pop_back`），先构造右子树再左子树
  ```cpp
  TreeNode* deserialize(deque<string>& nodes) {
      string val = nodes.back(); nodes.pop_back();
      if(val == "#") return nullptr;
      TreeNode* root = new TreeNode(stoi(val));
      root->right = deserialize(nodes);  // 先右后左！
      root->left = deserialize(nodes);
      return root;
  }
  ```

### 方法三：层序遍历
- 序列化：BFS，空节点也入队并标记为 `#`
- 反序列化：BFS，每次从流中取两个元素作为当前节点的左右子节点
- 注意：`stringstream + getline` 按分隔符拆分字符串

### 关键点
- 前序/后序可以序列化，中序不行（无法确定根节点位置）
- 空节点必须标记，否则无法唯一确定树结构
- 字符串分割：手动遍历 或 `stringstream + getline(ss, token, ',')`

## 寻找重复的子树（652）
- 核心思路：后序位置序列化每棵子树，用哈希表记录出现次数
- 当某子树序列化结果第二次出现时，加入结果集
  ```cpp
  unordered_map<string, int> mp;
  vector<TreeNode*> res;
  string serialize(TreeNode* root) {
      if(root == nullptr) return "#";
      string left = serialize(root->left);
      string right = serialize(root->right);
      string myself = left + "," + right + "," + to_string(root->val);
      if(mp[myself] == 1) res.push_back(root);  // 第二次出现
      mp[myself]++;
      return myself;
  }
  ```
- 时间复杂度 O(N²)（每个节点的序列化字符串拼接），可用三元组编号优化到 O(N)

### 构造二叉树的通用套路
1. 确定根节点（前序第一个 / 后序最后一个 / 区间最大值）
2. 用哈希表 O(1) 查找根在另一个序列中的位置
3. 计算 `leftSize` 划分左右子树
4. 递归构造，注意索引边界（画图帮助理解）

## N 叉树遍历
- 与二叉树类似，用 `for` 循环遍历所有子节点
- N 叉树**没有中序遍历**（中序位置只对二叉树有意义）
  ```cpp
  void traverse(Node* root) {
      if(root == nullptr) return;
      // 前序位置
      for(Node* child : root->children) { traverse(child); }
      // 后序位置
  }
  ```

## 邻接表表示树结构
- 适用场景：输入为边列表 `(u, v)` 而非指针结构
- 用无向图存储，遍历时通过 parent 参数排除父节点
  ```cpp
  void traverse(int node, int parent) {
      vector<int> children;
      for(int child : tree[node]) {
          if(child != parent) children.push_back(child);
      }
      // 前序/中序/后序位置...
  }
  ```
- 无向图每条边存两次，节点编号从 1 开始时数组大小为 `n + 1`

## 相关题目
| 题号 | 题目 | 难度 |
|------|------|------|
| 94 | 二叉树的中序遍历 | 简单 |
| 102 | 二叉树的层序遍历 | 中等 |
| 104 | 二叉树的最大深度 | 简单 |
| 105 | 从前序与中序遍历序列构造二叉树 | 中等 |
| 106 | 从中序与后序遍历序列构造二叉树 | 中等 |
| 111 | 二叉树的最小深度 | 简单 |
| 114 | 二叉树展开为链表 | 中等 |
| 116 | 填充每个节点的下一个右侧节点指针 | 中等 |
| 144 | 二叉树的前序遍历 | 简单 |
| 145 | 二叉树的后序遍历 | 简单 |
| 222 | 完全二叉树的节点个数 | 简单 |
| 226 | 翻转二叉树 | 简单 |
| 257 | 二叉树的所有路径 | 简单 |
| 429 | N 叉树的层序遍历 | 中等 |
| 543 | 二叉树的直径 | 简单 |
| 589 | N 叉树的前序遍历 | 简单 |
| 590 | N 叉树的后序遍历 | 简单 |
| 297 | 二叉树的序列化与反序列化 | 困难 |
| 652 | 寻找重复的子树 | 中等 |
| 654 | 最大二叉树 | 中等 |
| 889 | 根据前序和后序遍历构造二叉树 | 中等 |
