# 归并排序与逆序对

## 核心思想

归并排序的 merge 过程天然地在比较"跨组元素对"，而且不重复不遗漏。利用这个性质，可以在排序的同时统计满足某种条件的元素对。

**本质：所有"统计满足条件的元素对"问题，如果暴力 O(n²) 超时，都可以考虑归并排序优化到 O(nlogn)。**

## 归并排序模板（912）

```cpp
vector<int> temp;

void mergeSort(vector<int>& nums, int lo, int hi) {
    if(lo >= hi) return;
    int mid = lo + (hi - lo) / 2;
    mergeSort(nums, lo, mid);
    mergeSort(nums, mid + 1, hi);
    merge(nums, lo, mid, hi);
}

void merge(vector<int>& nums, int lo, int mid, int hi) {
    for(int i = lo; i <= hi; i++) temp[i] = nums[i];
    int i = lo, j = mid + 1;
    for(int p = lo; p <= hi; p++) {
        if(i == mid + 1) {
            nums[p] = temp[j++];
        } else if(j == hi + 1) {
            nums[p] = temp[i++];
        } else if(temp[i] <= temp[j]) {
            nums[p] = temp[i++];
        } else {
            nums[p] = temp[j++];
        }
    }
}
```

## 为什么归并排序能统计元素对？

```
归并排序保证：
1. 同组内的比较 → 在更深层的递归中已经完成 ✓
2. 跨组的比较   → 在当前层 merge 中完成 ✓
3. 不重复不遗漏 → 每对元素恰好在某一层被比较一次 ✓
```

merge 时左半边 `[lo, mid]` 和右半边 `[mid+1, hi]` 都已排好序，可以利用有序性用双指针 O(n) 扫描，而不是暴力 O(n²)。

## 题目演进路线

```
912 归并排序（基础模板）
 │
 ├── LCR 170 逆序对（站在右边元素角度统计）
 │
 ├── 315 计算右侧小于当前元素的个数（站在左边元素角度统计 + 索引追踪）
 │
 ├── 493 翻转对（比较条件不同于排序条件 → 单独循环统计）
 │
 └── 327 区间和的个数（前缀和转化 + 归并统计 + 滑动窗口思想）
```

## 逆序对（LCR 170）

> 找所有 i < j 且 nums[i] > nums[j] 的对数

站在**右边元素**的角度统计：当取右边 `temp[j]` 时，说明它比左边剩余的 `[i, mid]` 都小，产生 `mid - i + 1` 个逆序对。

```cpp
// merge 中，当 temp[i] > temp[j] 时：
nums[p] = temp[j++];
count += mid - i + 1;  // 左边 [i, mid] 都比 temp[j] 大
```

**关键理解：** 右边元素被取走时就已经统计完了，所以右边用完（`j == hi + 1`）时不需要额外处理。

## 计算右侧小于当前元素的个数（315）

> 对每个 nums[i]，统计它右边比它小的元素个数

站在**左边元素**的角度统计：当取左边 `temp[i]` 时，右边已经被取走的 `[mid+1, j-1]` 都比它小。

**难点：** 排序会打乱原始索引，需要额外维护索引数组。

```cpp
vector<int> count;      // 结果数组
vector<int> index;      // 原始索引
vector<int> tempIndex;  // 辅助索引数组

// merge 中，当取左边元素时：
nums[p] = temp[i];
index[p] = tempIndex[i];
count[tempIndex[i]] += j - mid - 1;  // 右边已取走的都比它小
i++;
```

**两个统计时机：**
1. `temp[i] <= temp[j]`：取左边时，`count += j - mid - 1`
2. `j == hi + 1`（右边用完）：左边剩余元素也要统计，`count += j - mid - 1`（即 `hi - mid`）

### 315 vs LCR 170 的区别

| | LCR 170 逆序对 | 315 右侧更小 |
|---|---|---|
| 统计角度 | 右边元素 | 左边元素 |
| 统计时机 | 取右边时加 | 取左边时加 |
| 需要索引 | 不需要（只要总数） | 需要（每个元素单独计数） |
| 额外数组 | 无 | index + tempIndex |

## 翻转对（493）

> 找所有 i < j 且 nums[i] > 2 * nums[j] 的对数

**关键区别：** 比较条件（`> 2*`）和排序条件（`>`）不同，没办法在 merge 的比较中顺便统计。

**解决方案：** 在 merge 之前，单独写一个循环统计。此时左右两半都已排好序，可以用双指针 O(n) 扫描。

```cpp
void mergeSort(vector<int>& nums, int lo, int hi) {
    if(lo >= hi) return;
    int mid = lo + (hi - lo) / 2;
    mergeSort(nums, lo, mid);
    mergeSort(nums, mid + 1, hi);

    // ★ merge 之前先统计翻转对
    int j = mid + 1;
    for(int i = lo; i <= mid; i++) {
        while(j <= hi && (long long)nums[i] > (long long)2 * nums[j]) {
            j++;
        }
        count += j - (mid + 1);
    }

    merge(nums, lo, mid, hi);  // 标准 merge，不做额外统计
}
```

**为什么 j 不用重置？** 因为左半边是升序的，`nums[i]` 递增，满足条件的 j 范围只会右移（单调性），所以双指针总共 O(n)。

**注意：** `2 * nums[j]` 可能溢出 int，需要转 `long long`。

## 区间和的个数（327）

> 找所有子数组 [i, j] 使得 lower <= sum(i, j) <= upper

**转化思路：**
1. 子数组和 = `preSum[j+1] - preSum[i]`
2. 问题变成：找多少对 (i, j) 满足 `i < j` 且 `lower <= preSum[j] - preSum[i] <= upper`
3. 这就是在前缀和数组上找"满足条件的元素对"，和 315/493 一个套路

```cpp
// 对前缀和数组做归并排序
// merge 之前，统计跨组的满足条件的对数
// 维护左闭右开区间 [start, end)
int start = mid + 1, end = mid + 1;
for(int i = lo; i <= mid; i++) {
    while(start <= hi && nums[start] - nums[i] < lower) start++;
    while(end <= hi && nums[end] - nums[i] <= upper) end++;
    count += end - start;
}
```

**为什么 start 和 end 不用重置？** 同样是单调性：`nums[i]` 递增，`nums[?] - nums[i]` 递减，所以满足条件的区间 [start, end) 只会右移。

**注意：** 前缀和可能溢出 int，用 `long` 类型。

## 解题套路总结

遇到"统计满足条件的元素对"问题：

1. **判断能否用归并：** 条件是否涉及两个元素的大小关系？暴力是否 O(n²)？
2. **确定统计角度：**
   - 需要每个元素单独计数 → 站在左边角度（如 315）
   - 只需要总数 → 站在右边角度更简洁（如 LCR 170）
3. **确定统计位置：**
   - 比较条件和排序条件一致 → 在 merge 内部顺便统计（如 315、LCR 170）
   - 比较条件和排序条件不同 → 在 merge 之前单独统计（如 493、327）
4. **注意事项：**
   - 需要追踪原始索引时，维护 index 数组（如 315）
   - 可能溢出时用 `long long`（如 493 的 `2*nums[j]`、327 的前缀和）
   - 利用有序性 + 双指针/滑动窗口保证 O(n) 扫描

## 相关题目
| 题号 | 题目 | 难度 | 关键点 |
|------|------|------|------|
| 912 | 排序数组 | 中等 | 归并排序模板 |
| LCR 170 | 交易逆序对的总数 | 困难 | 右边角度统计 |
| 315 | 计算右侧小于当前元素的个数 | 困难 | 左边角度 + 索引追踪 |
| 493 | 翻转对 | 困难 | merge 前单独统计 |
| 327 | 区间和的个数 | 困难 | 前缀和转化 + 滑动窗口 |
