# 贪心算法

## 核心思想

贪心算法在每一步都做出当前看起来最优的选择，不回退，期望通过局部最优达到全局最优。

关键：证明贪心选择性质（局部最优 → 全局最优）。

## 一、跳跃游戏（55）

判断能否从起点跳到终点。

贪心策略：维护当前能到达的最远位置 `farthest`，如果遍历过程中 `farthest <= i`，说明被卡住了。

```cpp
bool canJump(vector<int>& nums) {
    int n = nums.size();
    int farthest = 0;
    for(int i = 0; i < n - 1; i++) {
        farthest = max(farthest, i + nums[i]);
        // 碰到 0，卡住跳不动了
        if(farthest <= i) return false;
    }
    return farthest >= n - 1;
}
```

## 二、跳跃游戏 II（45）

求从起点跳到终点的最少跳跃次数。

贪心策略：维护当前跳跃能到达的边界 `end`，在边界内贪心选择能跳最远的位置。当遍历到 `end` 时，必须再跳一步，更新 `end = farthest`。

```cpp
int jump(vector<int>& nums) {
    int n = nums.size();
    if(n <= 1) return 0;
    // end: 当前跳跃次数能到达的最远边界
    // farthest: 在 [i, end] 范围内能跳到的最远位置
    int end = 0, farthest = 0, jumps = 0;
    for(int i = 0; i < n - 1; i++) {
        farthest = max(farthest, i + nums[i]);
        if(i == end) {
            jumps++;
            end = farthest;
            if(farthest >= n - 1) return jumps;
        }
    }
    return -1;
}
```

对比 DP 解法（O(n²)）：`dp(i)` 表示从索引 i 跳到终点的最少步数，穷举每一步能跳的距离取最小值。贪心将其优化到 O(n)。

## 相关题目

| 题号 | 题目 | 难度 | 备注 |
|------|------|------|------|
| 55 | 跳跃游戏 | 中等 | 维护最远可达位置 |
| 45 | 跳跃游戏 II | 中等 | 贪心跳跃边界，O(n) |
