# 回溯算法

> 回溯算法是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来丢弃该解，即**回溯**并尝试其他路径。

---

## 核心框架

```cpp
// 路径：记录在 track 中
// 选择列表：当前可以做出的选择
// 结束条件：到达决策树底层，无法再做出选择

void backtrack(参数) {
    if (满足结束条件) {
        res.push_back(track);  // 收集结果
        return;
    }
    
    for (选择 in 选择列表) {
        做选择;
        backtrack(下一层);
        撤销选择;  // 回溯
    }
}
```

**核心三要素**：
1. **路径** (`track`)：已做出的选择
2. **选择列表**：当前可以做的选择
3. **结束条件**：到达决策树底层，无法再选择

---

## 一、子集与组合问题

> **核心观点**：子集问题和组合问题本质上是**一样的**，都是通过 `start` 参数控制遍历起点，唯一的区别是 **base case（结束条件）** 不同。

| 问题 | base case | 收集位置 |
|------|-----------|----------|
| 子集 | 无（遍历完所有元素自然结束） | 前序位置（每个节点都是子集） |
| 组合 | `track.size() == k` | 满足 k 个元素时收集 |

### 形式一：元素无重不可复选

**特征**：`nums` 中的元素都是唯一的，每个元素最多只能被使用一次。

**代表题目**：
- 78. 子集
- 77. 组合

**代码模板**：

```cpp
void backtrack(vector<int>& nums, int start) {
    // 子集：前序位置收集所有节点
    res.push_back(track);
    
    // 组合：满足条件时收集
    // if (track.size() == k) {
    //     res.push_back(track);
    //     return;  // 注意组合这里要 return
    // }
    
    for (int i = start; i < nums.size(); i++) {
        track.push_back(nums[i]);
        backtrack(nums, i + 1);  // i+1：不可重复选择
        track.pop_back();
    }
}
```

**关键理解**：
- `start` 参数控制树枝的遍历起点，避免产生重复的子集/组合
- `i + 1` 表示当前元素不能被重复选择

---

### 形式二：元素可重不可复选

**特征**：`nums` 中的元素可以存在重复，每个元素最多只能被使用一次。

**代表题目**：
- 90. 子集 II
- 40. 组合总和 II

**代码模板**：

```cpp
void backtrack(vector<int>& nums, int start) {
    res.push_back(track);  // 子集在前序收集
    
    // 组合的 base case
    // if (track.size() == k) { ... }
    
    for (int i = start; i < nums.size(); i++) {
        // 剪枝：同一层遇到相同元素，只选第一个
        if (i > start && nums[i] == nums[i - 1]) continue;
        
        track.push_back(nums[i]);
        backtrack(nums, i + 1);  // 不可重复选择
        track.pop_back();
    }
}

// 主函数中先排序！
sort(nums.begin(), nums.end());
```

**去重逻辑深度理解**：

```
假设 nums = [1, 2, 2']（排序后，用 2' 表示第二个2）

回溯树某一层的选择：
- i = start: 选 1 → 进入下一层
- i = start+1: 选 2 → 进入下一层  
- i = start+2: 选 2'，但 nums[i] == nums[i-1]，跳过！

为什么 i > start 才剪枝？
- i == start：这是当前层的"入口"，不管值是什么都要尝试（进入新层）
- i > start：在当前层内移动，遇到和前面相同的值就跳过（同层去重）
```

---

### 形式三：元素无重可复选

**特征**：`nums` 中的元素都是唯一的，每个元素可以被使用若干次。

**代表题目**：
- 39. 组合总和

**代码模板**：

```cpp
void backtrack(vector<int>& nums, int start, int target) {
    if (trackSum == target) {
        res.push_back(track);
        return;
    }
    if (trackSum > target) return;  // 剪枝
    
    for (int i = start; i < nums.size(); i++) {
        track.push_back(nums[i]);
        trackSum += nums[i];
        backtrack(nums, i, target);  // i：可重复选择当前元素！
        trackSum -= nums[i];
        track.pop_back();
    }
}
```

**关键区别**：
- `backtrack(nums, i, target)` 而不是 `i + 1`
- 传 `i` 表示当前元素可以重复选，传 `i + 1` 表示不能重复选

---

### 三种形式对比表

| 形式 | 元素唯一性 | 可否重复选 | start 传递 | 特殊处理 |
|------|-----------|-----------|-----------|----------|
| 形式一 | 唯一 | 不可 | `i + 1` | 无 |
| 形式二 | 可重复 | 不可 | `i + 1` | 先排序，`i>start && nums[i]==nums[i-1]` 剪枝 |
| 形式三 | 唯一 | 可以 | `i` | 无 |

---

## 二、排列问题

> **核心区别**：排列问题关注**顺序**，`[1,2]` 和 `[2,1]` 是两个不同的排列。因此排列问题不使用 `start` 参数，而是用 `used` 数组记录每个元素是否被使用过。

### 形式一：元素无重

**代表题目**：46. 全排列

**代码模板**：

```cpp
// 使用 vector<char> 比 vector<bool> 更快（位压缩原因）
vector<char> used;

void backtrack(vector<int>& nums) {
    if (track.size() == nums.size()) {
        res.push_back(track);
        return;
    }
    
    for (int i = 0; i < nums.size(); i++) {
        if (used[i]) continue;  // 跳过已使用的元素
        
        track.push_back(nums[i]);
        used[i] = 1;
        backtrack(nums);
        used[i] = 0;
        track.pop_back();
    }
}
```

**与子集/组合的关键区别**：
- 没有 `start` 参数，每次从 0 开始遍历
- 用 `used` 数组标记元素是否已被选择
- 结果在 `track.size() == nums.size()` 时收集（必须选满）

---

### 形式二：元素可重

**代表题目**：47. 全排列 II

**代码模板**：

```cpp
void backtrack(vector<int>& nums) {
    if (track.size() == nums.size()) {
        res.push_back(track);
        return;
    }
    
    for (int i = 0; i < nums.size(); i++) {
        if (used[i]) continue;
        
        // 关键剪枝：固定相同元素的相对位置
        // 如果前一个相等元素没有用过，则跳过当前元素
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue;
        
        track.push_back(nums[i]);
        used[i] = 1;
        backtrack(nums);
        used[i] = 0;
        track.pop_back();
    }
}

// 主函数中先排序！
sort(nums.begin(), nums.end());
```

**去重逻辑深度理解**：

```
假设 nums = [1, 2, 2']（已排序）

情况1：先选 2，再选 2'
- used[1]=true, used[2]=false
- 选 2' 时，nums[2]==nums[1] 且 !used[1]=false，不剪枝 ✓

情况2：直接选 2'（2 还没选）
- used[1]=false
- 选 2' 时，nums[2]==nums[1] 且 !used[1]=true，剪枝！✗

结论：这保证了相同元素在排列中的相对顺序与原始数组一致，
      从而避免生成重复排列。
```

---

## 三、子集/组合 vs 排列 对比

| 特性 | 子集/组合 | 排列 |
|------|----------|------|
| 关注点 | 元素的选择（选/不选） | 元素的顺序 |
| 控制方式 | `start` 参数 | `used` 数组 |
| 遍历起点 | 从 `start` 开始 | 从 0 开始 |
| 结果收集 | 子集：前序位置<br>组合：满足条件时 | 选满所有元素时 |
| 重复元素去重 | `i > start && nums[i] == nums[i-1]` | `i > 0 && nums[i] == nums[i-1] && !used[i-1]` |

---

## 四、二维回溯/棋盘问题

> N皇后、解数独这类二维棋盘问题，本质仍是回溯，只是决策点变成了**每一行/每一个格子**。

### 1. N 皇后（51、52）

**核心思想**：逐行放置皇后，每行只能放一个，检查列和两条对角线是否冲突。

```cpp
void backtrack(vector<string>& board, int row) {
    if (row == board.size()) {
        // 51题：收集所有解
        res.push_back(board);
        // 52题：只是计数
        // count++;
        return;
    }
    
    for (int col = 0; col < n; col++) {
        if (!isValid(board, row, col)) continue;
        
        board[row][col] = 'Q';
        backtrack(board, row + 1);  // 下一行
        board[row][col] = '.';      // 撤销选择
    }
}

// 检查在 (row, col) 放置皇后是否合法
bool isValid(vector<string>& board, int row, int col) {
    int n = board.size();
    // 检查列（只需要检查上方，下方还没放）
    for (int i = 0; i < row; i++) {
        if (board[i][col] == 'Q') return false;
    }
    // 检查右上方
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (board[i][j] == 'Q') return false;
    }
    // 检查左上方
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 'Q') return false;
    }
    return true;
}
```

**关键理解**：
- 只需要检查**上方**（已放置的），不需要检查下方（还没放）
- 同一行不会有两个皇后（每行只选一个位置）
- 51题收集所有解（`vector<vector<string>>`），52题只需计数（`int`）

---

### 2. 解数独（37）

**核心思想**：逐格填充，每个空格尝试 1-9，找到**一个可行解**即可。

```cpp
bool found = false;  // 标记是否已找到解

void backtrack(vector<vector<char>>& board, int index) {
    if (found) return;  // 已找到解，停止搜索
    
    if (index == 81) {  // 填完了
        found = true;
        return;
    }
    
    int i = index / 9, j = index % 9;
    
    if (board[i][j] != '.') {  // 预设数字，跳过
        backtrack(board, index + 1);
        return;
    }
    
    for (char ch = '1'; ch <= '9'; ch++) {
        if (!isValid(board, i, j, ch)) continue;
        
        board[i][j] = ch;
        backtrack(board, index + 1);
        
        // 关键：找到解后不要撤销选择！
        if (found) return;
        
        board[i][j] = '.';  // 撤销选择
    }
}
```

**为什么需要 `found` 标记？**

| 场景 | 处理方式 | 原因 |
|------|---------|------|
| 函数开头 `if(found) return` | 停止继续深入搜索 | 已经找到解了，不需要再找 |
| 递归后 `if(found) return` | 阻止撤销选择 | 解就在 `board` 里，撤销会把答案擦除 |

**与 N 皇后的区别**：
- N 皇后：`res.push_back(board)` 是**拷贝**，后续修改不影响已存的结果
- 解数独：要**直接修改输入的 board**，找到后必须保住状态

---

### 3. 二维回溯通用技巧

| 技巧 | 说明 |
|------|------|
| **逐行推进** | N 皇后用 `row` 参数，每行只做一个决策 |
| **逐格推进** | 数独用 `index` 参数，按行优先顺序遍历所有格子 |
| **坐标转换** | `i = index / n`, `j = index % n` |
| **只检查已放置的** | N 皇后只检查上方，数独检查同行同列同 3x3 宫 |

---

## 五、易错点提醒

1. **忘记排序**：形式二（元素可重）必须先排序才能去重
2. **剪枝条件写错**：
   - 子集/组合：`i > start && nums[i] == nums[i-1]`
   - 排列：`i > 0 && nums[i] == nums[i-1] && !used[i-1]`
3. **start 参数传错**：
   - 不可重复选 → `i + 1`
   - 可重复选 → `i`
4. **used 数组类型**：推荐用 `vector<char>` 而不是 `vector<bool>`（后者有位压缩，访问慢）
5. **忘记回溯**：做选择后记得在递归后撤销选择
6. **子集 vs 组合 base case**：
   - 子集：前序位置收集，没有 return
   - 组合：满足条件时收集，要 return
7. **解数独的 `found`**：找到解后要阻止撤销选择，否则答案会被擦除
