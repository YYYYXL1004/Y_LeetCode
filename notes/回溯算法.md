# 回溯算法

> 回溯算法是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来丢弃该解，即**回溯**并尝试其他路径。

---

## 核心框架

```cpp
// 路径：记录在 track 中
// 选择列表：当前可以做出的选择
// 结束条件：到达决策树底层，无法再做出选择

void backtrack(参数) {
    if (满足结束条件) {
        res.push_back(track);  // 收集结果
        return;
    }
    
    for (选择 in 选择列表) {
        做选择;
        backtrack(下一层);
        撤销选择;  // 回溯
    }
}
```

**核心三要素**：
1. **路径** (`track`)：已做出的选择
2. **选择列表**：当前可以做的选择
3. **结束条件**：到达决策树底层，无法再选择

---

## 一、子集与组合问题

> **核心观点**：子集问题和组合问题本质上是**一样的**，都是通过 `start` 参数控制遍历起点，唯一的区别是 **base case（结束条件）** 不同。

| 问题 | base case | 收集位置 |
|------|-----------|----------|
| 子集 | 无（遍历完所有元素自然结束） | 前序位置（每个节点都是子集） |
| 组合 | `track.size() == k` | 满足 k 个元素时收集 |

### 形式一：元素无重不可复选

**特征**：`nums` 中的元素都是唯一的，每个元素最多只能被使用一次。

**代表题目**：
- 78. 子集
- 77. 组合

**代码模板**：

```cpp
void backtrack(vector<int>& nums, int start) {
    // 子集：前序位置收集所有节点
    res.push_back(track);
    
    // 组合：满足条件时收集
    // if (track.size() == k) {
    //     res.push_back(track);
    //     return;  // 注意组合这里要 return
    // }
    
    for (int i = start; i < nums.size(); i++) {
        track.push_back(nums[i]);
        backtrack(nums, i + 1);  // i+1：不可重复选择
        track.pop_back();
    }
}
```

**关键理解**：
- `start` 参数控制树枝的遍历起点，避免产生重复的子集/组合
- `i + 1` 表示当前元素不能被重复选择

---

### 形式二：元素可重不可复选

**特征**：`nums` 中的元素可以存在重复，每个元素最多只能被使用一次。

**代表题目**：
- 90. 子集 II
- 40. 组合总和 II

**代码模板**：

```cpp
void backtrack(vector<int>& nums, int start) {
    res.push_back(track);  // 子集在前序收集
    
    // 组合的 base case
    // if (track.size() == k) { ... }
    
    for (int i = start; i < nums.size(); i++) {
        // 剪枝：同一层遇到相同元素，只选第一个
        if (i > start && nums[i] == nums[i - 1]) continue;
        
        track.push_back(nums[i]);
        backtrack(nums, i + 1);  // 不可重复选择
        track.pop_back();
    }
}

// 主函数中先排序！
sort(nums.begin(), nums.end());
```

**去重逻辑深度理解**：

```
假设 nums = [1, 2, 2']（排序后，用 2' 表示第二个2）

回溯树某一层的选择：
- i = start: 选 1 → 进入下一层
- i = start+1: 选 2 → 进入下一层  
- i = start+2: 选 2'，但 nums[i] == nums[i-1]，跳过！

为什么 i > start 才剪枝？
- i == start：这是当前层的"入口"，不管值是什么都要尝试（进入新层）
- i > start：在当前层内移动，遇到和前面相同的值就跳过（同层去重）
```

---

### 形式三：元素无重可复选

**特征**：`nums` 中的元素都是唯一的，每个元素可以被使用若干次。

**代表题目**：
- 39. 组合总和

**代码模板**：

```cpp
void backtrack(vector<int>& nums, int start, int target) {
    if (trackSum == target) {
        res.push_back(track);
        return;
    }
    if (trackSum > target) return;  // 剪枝
    
    for (int i = start; i < nums.size(); i++) {
        track.push_back(nums[i]);
        trackSum += nums[i];
        backtrack(nums, i, target);  // i：可重复选择当前元素！
        trackSum -= nums[i];
        track.pop_back();
    }
}
```

**关键区别**：
- `backtrack(nums, i, target)` 而不是 `i + 1`
- 传 `i` 表示当前元素可以重复选，传 `i + 1` 表示不能重复选

---

### 三种形式对比表

| 形式 | 元素唯一性 | 可否重复选 | start 传递 | 特殊处理 |
|------|-----------|-----------|-----------|----------|
| 形式一 | 唯一 | 不可 | `i + 1` | 无 |
| 形式二 | 可重复 | 不可 | `i + 1` | 先排序，`i>start && nums[i]==nums[i-1]` 剪枝 |
| 形式三 | 唯一 | 可以 | `i` | 无 |

---

## 二、排列问题

> **核心区别**：排列问题关注**顺序**，`[1,2]` 和 `[2,1]` 是两个不同的排列。因此排列问题不使用 `start` 参数，而是用 `used` 数组记录每个元素是否被使用过。

### 形式一：元素无重

**代表题目**：46. 全排列

**代码模板**：

```cpp
// 使用 vector<char> 比 vector<bool> 更快（位压缩原因）
vector<char> used;

void backtrack(vector<int>& nums) {
    if (track.size() == nums.size()) {
        res.push_back(track);
        return;
    }
    
    for (int i = 0; i < nums.size(); i++) {
        if (used[i]) continue;  // 跳过已使用的元素
        
        track.push_back(nums[i]);
        used[i] = 1;
        backtrack(nums);
        used[i] = 0;
        track.pop_back();
    }
}
```

**与子集/组合的关键区别**：
- 没有 `start` 参数，每次从 0 开始遍历
- 用 `used` 数组标记元素是否已被选择
- 结果在 `track.size() == nums.size()` 时收集（必须选满）

---

### 形式二：元素可重

**代表题目**：47. 全排列 II

**代码模板**：

```cpp
void backtrack(vector<int>& nums) {
    if (track.size() == nums.size()) {
        res.push_back(track);
        return;
    }
    
    for (int i = 0; i < nums.size(); i++) {
        if (used[i]) continue;
        
        // 关键剪枝：固定相同元素的相对位置
        // 如果前一个相等元素没有用过，则跳过当前元素
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue;
        
        track.push_back(nums[i]);
        used[i] = 1;
        backtrack(nums);
        used[i] = 0;
        track.pop_back();
    }
}

// 主函数中先排序！
sort(nums.begin(), nums.end());
```

**去重逻辑深度理解**：

```
假设 nums = [1, 2, 2']（已排序）

情况1：先选 2，再选 2'
- used[1]=true, used[2]=false
- 选 2' 时，nums[2]==nums[1] 且 !used[1]=false，不剪枝 ✓

情况2：直接选 2'（2 还没选）
- used[1]=false
- 选 2' 时，nums[2]==nums[1] 且 !used[1]=true，剪枝！✗

结论：这保证了相同元素在排列中的相对顺序与原始数组一致，
      从而避免生成重复排列。
```

---

## 三、子集/组合 vs 排列 对比

| 特性 | 子集/组合 | 排列 |
|------|----------|------|
| 关注点 | 元素的选择（选/不选） | 元素的顺序 |
| 控制方式 | `start` 参数 | `used` 数组 |
| 遍历起点 | 从 `start` 开始 | 从 0 开始 |
| 结果收集 | 子集：前序位置<br>组合：满足条件时 | 选满所有元素时 |
| 重复元素去重 | `i > start && nums[i] == nums[i-1]` | `i > 0 && nums[i] == nums[i-1] && !used[i-1]` |

---

## 四、易错点提醒

1. **忘记排序**：形式二（元素可重）必须先排序才能去重
2. **剪枝条件写错**：
   - 子集/组合：`i > start && nums[i] == nums[i-1]`
   - 排列：`i > 0 && nums[i] == nums[i-1] && !used[i-1]`
3. **start 参数传错**：
   - 不可重复选 → `i + 1`
   - 可重复选 → `i`
4. **used 数组类型**：推荐用 `vector<char>` 而不是 `vector<bool>`（后者有位压缩，访问慢）
5. **忘记回溯**：做选择后记得在递归后撤销选择
6. **子集 vs 组合 base case**：
   - 子集：前序位置收集，没有 return
   - 组合：满足条件时收集，要 return
