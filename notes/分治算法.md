# 分治算法

分治（Divide and Conquer）是一种重要的算法思想，核心步骤：
1. **分**（Divide）：将原问题分解为若干个规模较小的子问题
2. **治**（Conquer）：递归地解决这些子问题
3. **合**（Combine）：将子问题的解合并为原问题的解

---

## 核心框架

```cpp
// 分治算法框架
Result solve(Problem problem) {
    // base case
    if (problem is small enough) {
        return solveDirectly(problem);
    }
    
    // 分解
    SubProblem[] subProblems = divide(problem);
    
    // 递归求解子问题
    Result[] subResults;
    for (SubProblem sub : subProblems) {
        subResults.add(solve(sub));
    }
    
    // 合并结果
    return combine(subResults);
}
```

---

## 经典题目

### 1. 为运算表达式设计优先级（241）

**核心思想**：以运算符为中心，将表达式分割成左右两部分，分别递归求解所有可能的结果，然后组合。

```cpp
class Solution {
public:
    unordered_map<string, vector<int>> memo;
    
    vector<int> diffWaysToCompute(string expression) {
        if (memo.count(expression)) return memo[expression];
        
        vector<int> res;
        for (size_t i = 0; i < expression.size(); i++) {
            char c = expression[i];
            if (c == '-' || c == '+' || c == '*') {
                // 分：以运算符为中心分割
                vector<int> left = diffWaysToCompute(expression.substr(0, i));
                vector<int> right = diffWaysToCompute(expression.substr(i + 1));
                
                // 合：组合左右结果
                for (int a : left) {
                    for (int b : right) {
                        if (c == '-') res.push_back(a - b);
                        else if (c == '+') res.push_back(a + b);
                        else if (c == '*') res.push_back(a * b);
                    }
                }
            }
        }
        
        // base case：纯数字
        if (res.empty()) {
            res.push_back(stoi(expression));
        }
        
        memo[expression] = res;
        return res;
    }
};
```

**要点**：
- 每个运算符都可能是最后执行的运算符
- 使用备忘录避免重复计算
- 时间复杂度：指数级（ Catalan 数）

---

### 2. 合并 K 个升序链表（23）- 分治解法

**核心思想**：将 K 个链表分成两半，递归合并左右两半，最后合并两个有序链表。

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;
        return merge(lists, 0, lists.size() - 1);
    }
    
    // 分治：合并 lists[start..end]
    ListNode* merge(vector<ListNode*>& lists, int start, int end) {
        if (start == end) return lists[start];
        
        int mid = start + (end - start) / 2;
        ListNode* left = merge(lists, start, mid);
        ListNode* right = merge(lists, mid + 1, end);
        
        return mergeTwoLists(left, right);
    }
    
    // 合并两个有序链表
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode dummy(-1);
        ListNode *p = &dummy, *p1 = l1, *p2 = l2;
        
        while (p1 && p2) {
            if (p1->val < p2->val) {
                p->next = p1;
                p1 = p1->next;
            } else {
                p->next = p2;
                p2 = p2->next;
            }
            p = p->next;
        }
        
        p->next = p1 ? p1 : p2;
        return dummy.next;
    }
};
```

**复杂度**：
- 时间：O(N log K)，N 为总节点数，K 为链表数
- 空间：O(log K)，递归栈深度

---

### 3. 不同的二叉搜索树 II（95）

**核心思想**：枚举每个数字作为根节点，递归生成左右子树的所有可能，然后组合。

```cpp
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        if (n == 0) return {};
        return build(1, n);
    }
    
    // 构建 [lo, hi] 范围内的所有BST
    vector<TreeNode*> build(int lo, int hi) {
        vector<TreeNode*> res;
        if (lo > hi) {
            res.push_back(nullptr);
            return res;
        }
        
        // 枚举每个数字作为根节点
        for (int i = lo; i <= hi; i++) {
            // 递归构建左右子树
            vector<TreeNode*> leftTrees = build(lo, i - 1);
            vector<TreeNode*> rightTrees = build(i + 1, hi);
            
            // 组合左右子树
            for (TreeNode* left : leftTrees) {
                for (TreeNode* right : rightTrees) {
                    TreeNode* root = new TreeNode(i);
                    root->left = left;
                    root->right = right;
                    res.push_back(root);
                }
            }
        }
        
        return res;
    }
};
```

---

## 分治 vs 回溯 vs 动态规划

| 算法 | 特点 | 应用场景 |
|------|------|----------|
| **分治** | 子问题独立，不重叠 | 归并排序、快速排序、树形问题 |
| **回溯** | 穷举所有可能，有选择/撤销 | 排列组合、N皇后、数独 |
| **动态规划** | 子问题重叠，有最优子结构 | 最值问题、计数问题、存在性问题 |

**关键区别**：
- 分治：子问题独立，**不共享重叠子问题**
- 动态规划：子问题重叠，需要**备忘录优化**

---

## 适用场景

1. **可以分解为相似子问题**：如数组对半分、树的左右子树
2. **子问题相互独立**：子问题的解不影响其他子问题
3. **可以合并子问题的解**：有明确的合并策略

经典应用：归并排序、快速排序、线段树、树状数组等。
