# 栈与队列

## 栈
- 核心特性：后进先出（LIFO），适合"最近匹配"或"回溯"问题
- 括号匹配：左括号入栈，遇到右括号时与栈顶匹配
- 路径简化：用栈维护目录层级，`..` 弹出栈顶，`.` 和空字符串跳过
- 用 `vector` 模拟栈：既有 `push_back/pop_back`，又方便最后顺序遍历
- `stringstream` + `getline(ss, token, '/')` 按分隔符分割字符串

## 最小栈
- 辅助栈同步记录当前最小值，新元素 ≤ 栈顶时才入辅助栈
- 弹出时若等于最小值，辅助栈也要弹出
  ```cpp
  void push(int val) {
      stk.push(val);
      if(minStk.empty() || val <= minStk.top()) minStk.push(val);
  }
  void pop() {
      if(stk.top() == minStk.top()) minStk.pop();
      stk.pop();
  }
  ```

## 循环队列
- 使用 `capacity = k + 1`，浪费一个空间区分空和满
- 下一个位置：`(cur + 1) % capacity`
- 上一个位置：`(cur - 1 + capacity) % capacity`
- 判空：`front == rear`；判满：`(rear + 1) % capacity == front`
  ```cpp
  bool enQueue(int value) {
      if(isFull()) return false;
      data[rear] = value;
      rear = (rear + 1) % capacity;
      return true;
  }
  int Rear() {
      if(isEmpty()) return -1;
      return data[(rear - 1 + capacity) % capacity];
  }
  ```

## LRU 缓存
- 哈希表 O(1) 查找 + 双向链表 O(1) 增删
- 双向链表使用虚拟头尾节点简化边界处理
- 最近使用的放链表尾部，最久未使用的在头部
- 核心操作拆分：`makeRecently`、`addRecently`、`deleteKey`、`removeLeastRecently`
  ```cpp
  // 双向链表节点
  class Node {
  public:
      int key, val;
      Node *next, *prev;
  };
  // get: 不存在返回-1，存在则 makeRecently 后返回值
  // put: 已存在则删旧加新；不存在且满了则 removeLeastRecently 再添加
  ```

## 相关题目
| 题号 | 题目 | 难度 |
|------|------|------|
| 20 | 有效的括号 | 简单 |
| 71 | 简化路径 | 中等 |
| 146 | LRU 缓存 | 中等 |
| 155 | 最小栈 | 中等 |
| 622 | 设计循环队列 | 中等 |
| 641 | 设计循环双端队列 | 中等 |
