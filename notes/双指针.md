# 双指针

## 对撞指针

- 盛最多水的容器：每次移动高度较小的指针（贪心），移动较高的不可能得到更大面积
- 有序数组的平方：两端向中间比较绝对值，较大值从后往前填入结果数组
  ```cpp
  int i = 0, j = n - 1, p = n - 1;
  while(i <= j) {
      if(abs(nums[i]) >= abs(nums[j])) {
          res[p--] = nums[i] * nums[i]; i++;
      } else {
          res[p--] = nums[j] * nums[j]; j--;
      }
  }
  ```
- 合并两个有序数组：从后往前双指针，避免覆盖 nums1 的有效元素

## 快慢指针

### 数组去重
- 模板：slow 指向不重复序列末尾，fast 遍历，遇到不同值时 `slow++; nums[slow] = nums[fast]`
- 保留最多 k 个重复：比较 `nums[fast]` 和 `nums[slow-k]`，不同则写入
- 另一种思路：分组处理，内层循环跳过相同元素并计数，最多写入 k 个
- 分组处理边界要点：外层 `fast < n`，内层先判断边界再访问元素

### 链表快慢指针
- 找中点：快指针走两步，慢指针走一步，快指针到末尾时慢指针在中点
- 成环检测：快慢指针相遇即有环
- 找环入口：相遇后，一个指针回到起点，两指针同速前进再次相遇即为入口
- 相交链表：先计算长度差，让长链表先走差值步，再同步前进找交点
- 删除倒数第 N 个节点：快指针先走 N+1 步，然后同步前进

## 三指针（荷兰国旗）
- p0 指向 0 区间末尾，p2 指向 2 区间开头，p 遍历
- 交换 0 后 p++，交换 2 后 p 不动（交换来的元素未处理）

## nSum 问题
- 通用模板：排序后递归降维，n > 2 时固定一个数转为 (n-1)Sum，n = 2 时双指针
- 去重：三个位置都要跳过重复值，`while(i < sz - 1 && nums[i] == nums[i+1]) i++`
  ```cpp
  // 调用前必须排序，n 填几数之和，start 从哪个索引开始，target 目标和
  vector<vector<int>> nSumTarget(vector<int>& nums, int n, int start, long long target) {
      int sz = nums.size();
      vector<vector<int>> res;
      if(n < 2 || sz < n) return res;
      if(n == 2) {
          int l = start, r = sz - 1;
          while(l < r) {
              int left = nums[l], right = nums[r], sum = left + right;
              if(sum == target) {
                  res.push_back({left, right});
                  while(l < r && nums[l] == left) l++;
                  while(l < r && nums[r] == right) r--;
              } else if(sum < target) {
                  while(l < r && nums[l] == left) l++;
              } else {
                  while(l < r && nums[r] == right) r--;
              }
          }
      } else {
          for(int i = start; i < sz; i++) {
              auto sub = nSumTarget(nums, n-1, i+1, target - nums[i]);
              for(auto& arr : sub) { arr.push_back(nums[i]); res.push_back(arr); }
              while(i < sz-1 && nums[i] == nums[i+1]) i++;
          }
      }
      return res;
  }
  ```
- 四数之和注意 target 用 `long` 防溢出

## 接雨水
- 暴力：每个位置找左右最高值，O(n²)
- 备忘录：预处理左右最高值数组，O(n) 时间 O(n) 空间（推荐）
- 双指针：动态维护 l_max 和 r_max，O(n) 时间 O(1) 空间
  ```cpp
  int left = 0, right = n - 1, l_max = 0, r_max = 0, res = 0;
  while(left < right) {
      l_max = max(l_max, height[left]);
      r_max = max(r_max, height[right]);
      if(l_max < r_max) { res += l_max - height[left]; left++; }
      else { res += r_max - height[right]; right--; }
  }
  // 关键：l_max < r_max 时，left 位置的积水只取决于 l_max，不用关心右边真正的最大值
  ```
- 接雨水 II（三维）：优先队列维护最低边界 + 从外向内 BFS

## 相关题目
| 题号 | 题目 | 难度 |
|------|------|------|
| 11 | 盛最多水的容器 | 中等 |
| 15 | 三数之和 | 中等 |
| 18 | 四数之和 | 中等 |
| 26 | 删除有序数组中的重复项 | 简单 |
| 27 | 移除元素 | 简单 |
| 42 | 接雨水 | 困难 |
| 75 | 颜色分类 | 中等 |
| 80 | 删除有序数组中的重复项 II | 中等 |
| 88 | 合并两个有序数组 | 简单 |
| 125 | 验证回文串 | 简单 |
| 141 | 环形链表 | 简单 |
| 142 | 环形链表 II | 中等 |
| 160 | 相交链表 | 简单 |
| 167 | 两数之和 II | 中等 |
| 283 | 移动零 | 简单 |
| 344 | 反转字符串 | 简单 |
| 407 | 接雨水 II | 困难 |
| 532 | 数组中的 k-diff 数对 | 中等 |
| 876 | 链表的中间结点 | 简单 |
| 977 | 有序数组的平方 | 简单 |
