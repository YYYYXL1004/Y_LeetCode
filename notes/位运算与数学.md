# 位运算与数学

## 一、位运算基础

### 常用操作速查表
| 操作 | 含义 | 示例 |
|------|------|------|
| `n & 1` | 取最低位 | 判断奇偶 |
| `n >> 1` | 右移一位 | 相当于 n/2 |
| `n << 1` | 左移一位 | 相当于 n*2 |
| `n & (n-1)` | 消除最低位的1 | Brian Kernighan |
| `n & (-n)` | 提取最低位的1（lowbit） | 树状数组核心 |
| `a ^ a = 0` | 相同异或为0 | 成对抵消 |
| `a ^ 0 = a` | 与0异或不变 | 保留原值 |
| `1 << i` | 第i位置1 | 构造掩码 |
| `n \| (1 << i)` | 第i位设为1 | 设置位 |
| `n & ~(1 << i)` | 第i位清零 | 清除位 |
| `n ^ (1 << i)` | 第i位翻转 | 切换位 |
| `(n >> i) & 1` | 读取第i位 | 检查位 |
| `n \| (n-1)` | 最低位的1及其右边全置1 | — |
| `(1 << n) - 1` | 低n位全1掩码 | 全集 |

### 统计二进制中1的个数（191）

三种方法：
```cpp
// 方法一：逐位检查（基础）
while(n) { count += n & 1; n >>= 1; }

// 方法二：Brian Kernighan（优雅，循环次数=1的个数）
while(n) { n &= n - 1; count++; }

// 方法三：内置函数（最快）
__builtin_popcount(n);
```

### 2 的幂判定（231）

```cpp
// 方法：Brian Kernighan 统计1的个数
bool isPowerOfTwo(int n) {
    if(n <= 0) return false;
    int cnt = 0;
    while(n) {
        n &= n - 1;  // 消除最低位的1
        cnt++;
    }
    return cnt == 1;
    // 或者直接用内置函数：return __builtin_popcountl(n) == 1;
}

// 更简洁的判断：2的幂二进制只有最高位是1
// n > 0 且 n & (n-1) == 0
bool isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}

// 变种：判断是否为4的幂
// 4的幂：在2的幂基础上，1出现在奇数位
bool isPowerOfFour(int n) {
    return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
    // 0x55555555 = 0b01010101010101010101010101010101
}
```

### 颠倒二进制位（190）

将32位整数的二进制位颠倒（逆序）。

```cpp
// 方法：逐位取出并放置到对称位置
int reverseBits(int n) {
    int res = 0;
    for(int i = 0; i < 32; i++) {
        res <<= 1;          // 左移res腾出来空间
        res |= (n & 1);     // 取出n的最后一位放到res最后一位
        n >>= 1;            // 右移n，处理下一位
    }
    return res;
}
```

### 异或的应用

**只出现一次的数字（136）：** 所有数异或，成对的抵消为0，剩下的就是答案。
```cpp
int res = 0;
for(int n : nums) res ^= n;
```

**只出现一次的数字 II（137）：** 其他数出现3次，逐位统计每一位上1的个数，对3取余。
```cpp
int res = 0;
for(int i = 0; i < 32; i++) {
    int count = 0;
    for(int n : nums) count += (n >> i) & 1;
    if(count % 3 != 0) res |= (1 << i);
}
```

**只出现一次的数字 III（260）：** 有两个数只出现一次，其他都出现两次。全体异或得到 `a ^ b`，用 `lowbit` 分组后分别异或。
```cpp
unsigned int xorall = 0;
// 1：全部异或，得到两个目标数的异或结果
for(int num : nums) xorall ^= num;

// 2：找到xorall最低位的 1
// 说明两个目标数在该位不同
// 注意：当 xorall = INT_MIN 时，-xorall 会溢出，所以用 unsigned int
unsigned int diffBit = xorall & (-xorall);

// 3：根据这一组分组异或
int a = 0, b = 0;
for(int num : nums) {
    if((num & diffBit) == 0) {
        a ^= num; // 该位为0的组
    } else {
        b ^= num; // 该位为1的组
    }
}
return {a, b};
```

**丢失的数字（268）：** 0~n 中缺失一个数，下标与值异或，剩下的是缺失的数。
```cpp
int n = nums.size();
int res = n; // 先放入 n（因为索引只到 n-1）

// 因为索引和元素相同时，异或结果为0，只有丢失的数字不会被异或为0
for(int i = 0; i < n; i++) {
    res ^= i ^ nums[i];
}
return res;
```

**汉明距离（461）/ 最少位翻转次数（2220）：** `x ^ y` 得到不同位的掩码，统计1的个数。
```cpp
return __builtin_popcount(x ^ y);
```

### 比特位计数（338）
- 简单做法：对每个数调用 `__builtin_popcount`
- DP 做法：`dp[i] = dp[i & (i-1)] + 1`（消除最低位1后的结果+1）

### 位掩码技巧（762）
将小集合编码为一个整数，用移位+与运算 O(1) 判断元素是否在集合中：
```cpp
// 0~20 中的质数：2,3,5,7,11,13,17,19
// 编码为位掩码：第2,3,5,7,11,13,17,19位为1
int PrimeMask = 0b10100010100010101100; // = 665772
// 判断 bits 是否为质数
if((PrimeMask >> bits) & 1) count++;
```

### lowbit：提取最低位的1
```cpp
int lowbit(int n) { return n & (-n); }
```
- 原理：`-n` 是 `n` 的补码（取反+1），与 `n` 做 AND 只保留最低位的1
- 例：`n = 0b101100`，`-n = 0b010100`，`n & (-n) = 0b000100`
- 应用：树状数组（BIT）的核心操作

### 子集枚举
竞赛高频操作，枚举一个集合的所有子集（包括空集）：
```cpp
// 枚举 mask 的所有非空子集
for(int sub = mask; sub > 0; sub = (sub - 1) & mask) {
    // sub 是 mask 的一个子集
}
// 如果需要包含空集，循环结束后单独处理 sub = 0

// 枚举大小为 k 的所有子集（n 个元素中选 k 个）
// Gosper's Hack
int s = (1 << k) - 1; // 最小的 k 位全1
while(s < (1 << n)) {
    // 处理 s
    int c = s & (-s);          // lowbit
    int r = s + c;             // 进位
    s = (((r ^ s) >> 2) / c) | r; // 下一个组合
}
```

### 状态压缩 DP
用整数的二进制位表示集合状态，常见于 n ≤ 20 的问题：
```cpp
// dp[mask] 表示已选集合为 mask 时的最优解
// 枚举 mask 中的每一位
for(int mask = 0; mask < (1 << n); mask++) {
    for(int i = 0; i < n; i++) {
        if(mask & (1 << i)) {  // 第 i 位在集合中
            // 从 dp[mask ^ (1 << i)] 转移（去掉第 i 位的状态）
        }
    }
}
```
常见场景：旅行商问题（TSP）、任务分配、棋盘覆盖

### 位运算代替算术（竞赛常用）
```cpp
// 交换两个数（不用临时变量）
a ^= b; b ^= a; a ^= b;

// 取绝对值（无分支，避免 if）
int abs_n = (n ^ (n >> 31)) - (n >> 31);

// 判断是否为 2 的幂
bool isPow2 = n > 0 && (n & (n - 1)) == 0;

// 向上取整到 2 的幂（C++20: std::bit_ceil）
unsigned int nextPow2(unsigned int n) {
    n--;
    n |= n >> 1; n |= n >> 2; n |= n >> 4;
    n |= n >> 8; n |= n >> 16;
    return n + 1;
}

// 取两数较大值（无分支，仅适用于不溢出的情况）
int max_val = b ^ ((a ^ b) & -(a > b));

// 快速乘/快速幂（取模场景）
long long quickPow(long long base, long long exp, long long mod) {
    long long res = 1;
    base %= mod;
    while(exp > 0) {
        if(exp & 1) res = res * base % mod;
        base = base * base % mod;
        exp >>= 1;
    }
    return res;
}
```

### 异或的高级性质
```cpp
// 前缀异或：类似前缀和，区间异或 = prefixXor[r+1] ^ prefixXor[l]
// 异或方程：a ^ b = c → a = b ^ c（已知任意两个可求第三个）
// 不进位加法：a + b = (a ^ b) + 2 * (a & b)
//   其中 a ^ b 是不进位的和，a & b 是进位的位置
```

### GCC 内置位运算函数
```cpp
__builtin_popcount(n)    // 1 的个数
__builtin_clz(n)         // 前导零个数（count leading zeros），n>0
__builtin_ctz(n)         // 末尾零个数（count trailing zeros），n>0
__builtin_parity(n)      // 1 的个数的奇偶性（奇数返回1）
// 64 位版本加 ll 后缀：__builtin_popcountll, __builtin_clzll 等
```
- `__builtin_clz(n)`：`31 - __builtin_clz(n)` = 最高位1的位置 = `floor(log2(n))`
- `__builtin_ctz(n)`：等价于 lowbit 的位置，即 `log2(n & -n)`

## 二、数学

### 质数筛

**埃拉托斯特尼筛（埃氏筛）** O(n log log n)：
- 对每个质数 p，标记其所有倍数为合数
- 优化：从 p² 开始标记（p*2, p*3... 已被更小质数标记过）
- 缺点：一个合数可能被多个质数重复标记

**欧拉筛（线性筛）** O(n)：
- 每个合数只被其最小质因子筛掉一次
- 关键：当 `i % primes[j] == 0` 时 break，避免用更大质因子标记
```cpp
vector<bool> isPrime(n, true);
vector<int> primes;
for(int i = 2; i < n; i++) {
    if(isPrime[i]) primes.push_back(i);
    for(int p : primes) {
        if(p * i >= n) break;
        isPrime[p * i] = false;
        if(i % p == 0) break; // 核心：保证每个合数只被最小质因子筛一次
    }
}
```

### 丑数（263）
丑数 = 质因子只包含 2, 3, 5 的正整数。不断除以 2/3/5，最终为1则是丑数。

## 相关题目
| 题号 | 题目 | 难度 |
|------|------|------|
| 136 | 只出现一次的数字 | 简单 |
| 137 | 只出现一次的数字 II | 中等 |
| 190 | 颠倒二进制位 | 简单 |
| 191 | 位1的个数 | 简单 |
| 204 | 计数质数 | 中等 |
| 231 | 2 的幂 | 简单 |
| 260 | 只出现一次的数字 III | 中等 |
| 263 | 丑数 | 简单 |
| 268 | 丢失的数字 | 简单 |
| 338 | 比特位计数 | 简单 |
| 461 | 汉明距离 | 简单 |
| 762 | 二进制表示中质数个计算置位 | 简单 |
| 2220 | 转换数字的最少位翻转次数 | 简单 |
