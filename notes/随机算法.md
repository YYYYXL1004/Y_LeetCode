# 随机算法

## Fisher-Yates 洗牌算法
- **从后往前**（推荐）：
  ```cpp
  for (int i = n-1; i > 0; i--) {
      int j = rand() % (i + 1);  // [0, i]
      swap(arr[i], arr[j]);
  }
  ```
- **从前往后**：
  ```cpp
  for (int i = 0; i < n; i++) {
      int j = i + rand() % (n - i);  // [i, n-1]
      swap(arr[i], arr[j]);
  }
  ```
- 核心：逐步缩小未处理区域，保证每种排列概率相等（1/n!）
- ⚠️ 随机范围是 `i + 1` 而不是固定的 `n - 1`

## 蓄水池抽样算法（Reservoir Sampling）
- 用于**不知道数据总量**或**无法随机访问**时等概率随机选择
- 核心：遍历时第 i 个元素以 `1/i` 概率被选中
  ```cpp
  int count = 0, result;
  while (curr) {
      count++;
      if (rand() % count == 0) result = curr->val;
      curr = curr->next;
  }
  ```
- 概率证明：第 k 个元素最终被选中概率 = (1/k) × (k/(k+1)) × ... × ((n-1)/n) = 1/n

## 按权重随机选择（前缀和 + 二分）
- 构建前缀和数组 → 生成 `[1, total]` 随机数 → 二分查找第一个 `>= target` 的位置
- 权重越大，对应区间越长，被命中概率越高

## C++ 随机数生成器
- **`rand()` 的问题**：质量不佳、线程不安全、范围有限（RAND_MAX = 32767）
- **`<random>` 库**（推荐）：
  ```cpp
  mt19937 gen;  // Mersenne Twister 生成器
  Solution() : gen(random_device{}()) {}  // 真随机种子初始化
  uniform_int_distribution<int> dis(0, n - 1);
  return dis(gen);
  ```
- `random_device{}`：真随机种子（基于硬件）
- `mt19937`：高质量伪随机数生成器（周期 2^19937-1）
- 调试技巧：`mt19937 gen(42);` 使用固定种子

## 相关题目
| 题号 | 题目 | 难度 |
|------|------|------|
| 382 | 链表随机节点 | 中等 |
| 384 | 打乱数组 | 中等 |
| 398 | 随机数索引 | 中等 |
| 528 | 按权重随机选择 | 中等 |
